= Лабораторная работа №5-6
Волбенко В.Д. <КЭ-413>
:description: Лабораторная работа №3-4
:toc:
:toc-title: Оглавление
:imagesdir: Pic
:figure-caption: Рисунок
:table-caption: Таблица

include::Titul1.adoc[]

== Добавление классов для программы

Добавление классов в программу на языке C++ является ключевым этапом разработки в объектно-ориентированном стиле. Классы позволяют структурировать код, группируя данные (поля) и методы (функции) в единую логическую сущность.

Для добавления класса в программу обычно создаются два файла: заголовочный файл (.h), который описывает интерфейс класса, и файл реализации (.cpp), содержащий определения методов. Такое разделение упрощает управление кодом, способствует повторному использованию и ускоряет процесс компиляции.

Заголовочный файл

В этом файле находится объявление класса, его полей, методов и других элементов интерфейса. Заголовочный файл выступает как "контракт", который описывает, как можно взаимодействовать с классом.

Файл реализации включает определения методов, определённых в заголовочном файле. Здесь реализуется логика работы класса, что позволяет изменять её без воздействия на код, который использует класс. Включение заголовочного файла в файл реализации осуществляется через директиву *#include*.

=== Класс ModeManager

Для реализации управления светодиодами в разных режимах была разработана система, основанная на использовании класса ModeManager. Архитектура проекта включает абстрактный интерфейс IModeManager, класс реализации ModeManager, а также конфигурацию режимов, представленную массивом указателей на объекты режимов (tMode).

Интерфейс IModeManager определяет базовые методы для работы с режимами, такие как их инициализация, обновление и переключение. Этот подход обеспечивает модульность и гибкость системы, позволяя реализовывать различные варианты управления.

Класс ModeManager реализует функциональность, заданную интерфейсом, и управляет массивом режимов, который передается ему через конструктор. Основные методы класса включают:

* InitModeManager для инициализации текущего режима;
* UpdateModeManager для обновления состояния текущего режима;
* SwitchModeManager для переключения на следующий режим.

Конфигурация массива режимов (tMode) реализована с использованием типа, основанного на std::array. Это позволяет хранить указатели на объекты, реализующие интерфейс IMode. Такой подход упрощает добавление новых режимов и соответствует принципам объектно-ориентированного программирования, включая принцип открытости/закрытости.

[plantuml]
----
@startuml

interface IModeManager {
  + Init()
  + Update()
  + Switch()
}

interface IButton {
  + IsPressed(): bool
}

class ModeManager {
  - tMode& modes
  - std::uint8_t currentModeType
  + Init()
  + Update()
  + Switch()
}

class Button<TPort, pinNumber> {
  + IsPressed(): bool
}

class ModeConfig {
  tMode : std::array<IMode*, 3>
}

IModeManager <|-- ModeManager
IButton <|-- Button

@enduml
----

Класс Button<TPort, pinNumber> предназначен для управления и обработки ввода с кнопки (или других подобных устройств) в микроконтроллерных или встроенных системах. Этот шаблонный класс, как видно из его структуры, абстрагирует взаимодействие с кнопкой, предоставляя функциональность для определения событий нажатия.

Ниже представлена реализация каждого класса на основе диаграммы UML:

Код для объявления класса IModeManager:

[source, cpp]
----
#ifndef IMODEMANAGER_H
#define IMODEMANAGER_H

class IModeManager
{
public:
  virtual void InitModeManager() = 0; 
  virtual void UpdateModeManager() = 0; 
  virtual void SwitchModeManager() = 0;
};

#endif
----

Код для объявления класса ModeConfig:

[source, cpp]
----
#ifndef MODECONFIG_H
#define MODECONFIG_H

#include "ledconfig.h"
#include "IMode.h"

using tMode = std::array<IMode*, 3>;

#endif
----

Код для объявления класса ModeManager (тело класса):

[source, cpp]
----
#ifndef MODEMANAGER_H
#define MODEMANAGER_H

#include "IModeManager.h"
#include "ModeManagerConfig.h" // for tMode

class ModeManager : public IModeManager
{
public:
  ModeManager(tMode& modes); 
  void InitModeManager() override; 
  void UpdateModeManager() override; 
  void SwitchModeManager() override; 
private:
  tMode& modes; 
  std::uint8_t currentModeType; 
};

#endif
----

Код для объявления класса ModeManager
16:39


(.cpp):

[source, cpp]
----
#include "ModeManager.h"

ModeManager::ModeManager(tMode& modeArr) : modes(modeArr), currentModeType(0) 
{
}

void ModeManager::InitModeManager() {
        modes[currentModeType]->Init();
}

void ModeManager::UpdateModeManager() {
        modes[currentModeType]->Update();
}

void ModeManager::SwitchModeManager() {
    currentModeType = (currentModeType + 1) % std::size(modes); 
        modes[currentModeType]->Init();
}
----

Далее необходимо реализовать переключение режимов с помощью кнопки, для этого перейдем к созданию класс для кнопки.

=== Класс Button

Класс Button используется для управления кнопками, часто применяемыми в различных приложениях, таких как системы ввода, интерфейсы управления или микроконтроллеры. 
Он может включать функционал для отслеживания состояния кнопки, обработки нажатий, выполнения действий при определенных событиях (например, одиночное нажатие, удержание, двойное нажатие).

Далее создадим классы `IButton` и `Button`.

В классе IButton определён метод IsPressed(), который необходимо реализовать в наследуемых классах. Этот метод предназначен для проверки, была ли нажата кнопка:

[source, cpp]
----
#ifndef IBUTTON_H
#define IBUTTON_H

class IButton {
public:
    virtual bool IsPressed() = 0;
};
#endif
----

Класс Button, наследующий от IButton, реализует метод IsPressed(). Этот метод проверяет состояние кнопки в определённом порту и возвращает true, если кнопка нажата (0 в состоянии порта):

[source, cpp]
----
#ifndef BUTTON_H
#define BUTTON_H
#include "IButton.h"

template<typename TPort, int pinNumber>
class Button : public IButton {
public:
      bool onClick() override
      {
         return (TPort::IDR::Get() & (1 << pinNumber)) == 0;
      }
};
#endif
----

Шаблонные параметры TPort и pinNumber позволяют адаптировать класс Button для работы с конкретными портами и номерами пинов. Для проверки состояния порта и определения сигнала на заданном пине используется метод Get() из TPort::IDR.

=== Выводы по работе с классами

Можно сделать следующие выводы:

.Организация кода:

Добавление классов позволяет структурировать программу, разделяя функциональность между компонентами.
Это упрощает чтение, поддержку и масштабирование кода.

.Роль заголовочных и файлов реализации:

Заголовочные файлы (.h): описывают интерфейсы классов, включая их поля, методы и конструкторы.
Файлы реализации (.cpp): содержат определения методов и логику работы классов.

.Пример использования класса ModeManager:

* Класс управляет режимами системы.
* Предоставляет интерфейс для выполнения следующих задач:
** Инициализация режимов.
** Обновление текущего режима.
** Переключение между режимами.

.Конфигурация режимов:

* Для хранения данных о режимах используется массив указателей на объекты.
* Такой подход обеспечивает:
* Гибкость в управлении режимами.
* Удобство при добавлении новых режимов.

Был создан класс Button, который обеспечивает взаимодействие пользователя с устройством. Этот класс отслеживает состояние кнопки, проверяет её на нажатие. Это позволяет управлять функциями устройства через пользовательский ввод.

== Настройка тактирования платы

Настройка тактирования в микроконтроллерах, таких как STM32F411RET6, определяет, с какой частотой будут работать разные части устройства, включая процессор, периферийные модули и вспомогательные системы.

.Внутренний осциллятор высокой скорости (HSI):

генерирует стабильную частоту, например, 16, 24 или 32 МГц, без использования внешних компонентов. Он подходит для задач, где важна скорость вычислений и обмен данными.

.Внешний кварцевый генератор высокой скорости (HSE) 

используется, когда требуется точная и стабильная частота. Обычно это кварцевый резонатор с частотой 8, 16 или 25 МГц. Такой генератор идеально подходит для задач, требующих высокой точности.

.Фазовый автоподстройки частоты (PLL)

позволяет увеличивать частоту сигнала от HSI или HSE до нужного значения. Это дает возможность гибко настраивать частоту системы в пределах характеристик микроконтроллера для выполнения различных задач.

Правильное тактирование платы важно для
16:39


стабильной работы всех её компонентов — процессора, памяти, периферийных устройств и интерфейсов с внешними системами. Настройка частоты должна учитывать особенности микроконтроллера и обеспечивать эффективное использование его ресурсов.

=== Пример кода с использованием HSI

HSI (High-Speed Internal) — это встроенный осциллятор высокой скорости, который используется в микроконтроллерах, например, STM32F411RET6, для создания стабильной частоты без применения внешних компонентов. Обычно его частота составляет 16, 24 или 32 МГц. Этот осциллятор обеспечивает базовую частоту работы системы, подходит для выполнения вычислений и передачи данных. Он используется для тактирования процессора и других внутренних модулей микроконтроллера.

[source, cpp]
----
std::uint32_t SystemCoreClock = 16'000'000U;

extern "C" 
int __low_level_init(void)

  RCC::CR::HSION::On::Set();
  while (RCC::CR::HSIRDY::NotReady::IsSet())
  {

  }
  //Переключение на внутренний генератор
  RCC::CFGR::SW::Hsi::Set();
  while (!RCC::CFGR::SWS::Hsi::IsSet())
  {

  }
  STK::CTRL::CLKSOURCE::CpuClock::Set();
  RCC::APB2ENR::SYSCFGEN::Enable::Set();

  return 1;
----

Далее приведено описание кода

Код выполняет начальную настройку микроконтроллера:

* Устанавливает системную частоту 16 МГц.
* Включает внутренний генератор HSI и ждет его готовности.
* Переключает систему на HSI как источник тактового сигнала.
* Настраивает таймер SysTick на системную частоту.
* Включает модуль SYSCFG.
* Возвращает 1 при успешной инициализации.

SysTick — это встроенный таймер в микроконтроллерах на базе ARM Cortex-M. Его используют для создания задержек, периодических событий или работы с операционными системами.

=== Пример кода с использованием HSE

HSE (High-Speed External) — это внешний кварцевый генератор, который используется в микроконтроллерах для создания точного и стабильного тактового сигнала. Частота HSE обычно составляет 8, 16 или 25 МГц. Он подключается к микроконтроллеру через внешний кварцевый резонатор и дает более точный сигнал, чем внутренние осцилляторы. HSE часто используется, когда нужно больше точности, например, для работы с периферийными устройствами или передачи данных.

[source, cpp]
----
std::uint32_t SystemCoreClock = 8'000'000U;

extern "C" 
int __low_level_init(void)

  //Switch on external 8 MHz oscillator
  RCC::CR::HSEON::On::Set();
  while (RCC::CR::HSERDY::NotReady::IsSet())
  {

  }
  //Switch system clock on external oscillator
  RCC::CFGR::SW::Hse::Set();
  while (!RCC::CFGR::SWS::Hse::IsSet())
  {

  }
  STK::CTRL::CLKSOURCE::CpuClock::Set();
  RCC::APB2ENR::SYSCFGEN::Enable::Set();

  return 1;
----

Этот код настраивает внешний кварцевый осциллятор (HSE) с частотой 8 МГц, переключает систему на его использование в качестве основного источника тактового сигнала и настраивает таймер и системные блоки. Включается также тактирование для системы конфигурации (SYSCFG).

=== Задание на PLL

PLL (Phase-Locked Loop) — это схема фазовой автоподстройки частоты, используемая в микроконтроллерах, таких как STM32F411RET6, для увеличения частоты внешнего или внутреннего источника (HSI или HSE) до нужной частоты системы. PLL позволяет изменять выходную частоту, умножая или деля входную, что полезно для получения высоких частот, если исходной частоты HSI или HSE недостаточно.

Используя PLL (<<PLL(set)>>), можно настроить тактовую частоту системы в пределах возможностей микроконтроллера, что дает гибкость при решении разных задач. Это особенно важно для управления скоростью работы процессора и периферийных устройств, которые требуют различных уровней производительности и энергопотребления.

f = f(hse) × (PLLN / PLLM) /PLLP

где: PLLM – делитель входной частоты; PLLN – множитель; PLLP – делитель на выходе PLL.

Для получения частоты 

f = 13.666МГц, например, выберем: PLLM = 8; PLLN = 137; PLLP = 8.

 Проверка f = 137 × 8 / 8 / 8 = 13.666 МГц.

[source, cpp]
----
std::uint32_t SystemCoreClock = 13'666'000U;

extern "C" 
int __low_level_init(void){
  
  RCC::CR::HSEON::On::Set();
  while (RCC::CR::HSERDY::NotReady::IsSet())
  {

  }
16:39


RCC::PLLCFGR::PLLSRC::HseSource::Set();

    //137
    RCC::PLLCFGR::PLLN0::Set(0b10001001);
   

    //8
    RCC::PLLCFGR::PLLP0::Set(0b11);
  

    //10
    RCC::PLLCFGR::PLLM0::Set(0b001011);
    

   
    RCC::CR::PLLON::On::Set();
    while (RCC::CR::PLLRDY::Unclocked::IsSet()) {
        
    }

    RCC::CFGR::SW::Pll::Set();
    while (!RCC::CFGR::SWS::Pll::IsSet()) {
      
    }

   
    RCC::APB2ENR::SYSCFGEN::Enable::Set();

    return 1;
}

----

== Заключение

Исходя из проделанной работы, можно выделить следующее:

Настройка тактирования микроконтроллера STM32F411RET6 включает выбор источников частоты для различных компонентов, таких как процессор и периферийные устройства. Внутренний осциллятор высокой скорости (HSI) генерирует стабильную частоту, которая подходит для быстрых вычислений и обмена данными внутри системы. Внешний кварцевый генератор высокой скорости (HSE) обеспечивает точную и стабильную частоту, необходимую для задач, требующих высокой точности.

Фазовый автоподстройки частоты (PLL) увеличивает частоту внутреннего или внешнего источника (HSI или HSE) до необходимой, что дает гибкость при выполнении различных операций. Настройка тактирования важна для надежной работы всех частей микроконтроллера, включая процессор, память и периферийные устройства. Пример на C++ показывает, как активировать внешние генераторы и настроить SysTick и SYSCFG для расширения возможностей системы.

Использование HSI и HSE обеспечивает стабильные и точные частоты для работы различных компонентов микроконтроллера. Примеры кода демонстрируют настройку системы с внешними генераторами на 16 и 8 МГц. Конфигурация PLL позволяет увеличить частоту для достижения нужной производительности и оптимизации энергопотребления.