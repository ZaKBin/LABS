= Лабораторная работа №5-6
Волбенко В.Д. <КЭ-413>
:description: Лабораторная работа №3-4
:toc:
:toc-title: Оглавление
:imagesdir: Pic
:figure-caption: Рисунок
:table-caption: Таблица

include::Titul1.adoc[]

== Создание новых классов для программы

Добавление классов в программу на C++ — это основа объектно-ориентированного программирования, которая помогает организовать код, делить функциональность между частями программы и облегчить её поддержку. Класс определяет свойства (данные) и поведение (методы) объектов, создаваемых на его основе.

Чтобы добавить новый класс, обычно создаются два файла: заголовочный (.h), который описывает интерфейс класса, и файл реализации (.cpp), где прописаны функции. Это разделение помогает организовать код, облегчает его повторное использование и ускоряет компиляцию.

Заголовочный файл описывает структуру класса, его данные, методы и доступ к ним. Это позволяет другим частям программы использовать класс, не зная деталей его реализации.

В файле реализации прописываются сами методы, объявленные в заголовочном файле. Это даёт возможность изменять внутреннюю логику класса, не затрагивая остальной код. Для связи файлов используется директива #include, которая подключает заголовочный файл к файлу реализации.

=== Класс ModeManager

Для управления светодиодами в разных режимах была создана система с использованием класса ModeManager. Проект построен на основе интерфейса IModeManager, самого класса ModeManager и массива режимов (tMode), который содержит указатели на объекты режимов.

Интерфейс IModeManager определяет основные методы: инициализацию, обновление и переключение режимов. Это делает систему гибкой и позволяет легко добавлять новые реализации управления.Класс ModeManager реализует методы интерфейса и управляет режимами через массив, который передается в конструктор. В нем есть три ключевых метода: InitModeManager для настройки текущего режима, UpdateModeManager для его работы и SwitchModeManager для переключения на следующий.

Массив режимов (tMode) сделан на основе std::array и содержит указатели на объекты, которые используют интерфейс IMode. Это позволяет легко добавлять новые режимы и упрощает работу с ними, следуя принципам объектно-ориентированного программирования, таким как открытость для расширений и закрытость для изменений.

[plantuml]
----
@startuml

interface IModeManager {
  + Init()
  + Update()
  + Switch()
}

interface IButton {
  + onClick(): bool
}

class ModeManager {
  - tMode& modes
  - std::uint8_t currentModeType
  + Init()
  + Update()
  + Switch()
}

class Button<TPort, pinNumber> {
  - bool currentStatus
  - std::uint32_t buttonPortStatus
  + onClick(): bool
}

class ModeConfig {
  tMode : std::array<IMode*, 3>
}

IModeManager <|-- ModeManager
IButton <|-- Button

@enduml
----

Класс Button<TPort, pinNumber> реализует функциональность кнопки, позволяя определять ее состояние (нажата или нет) и выполнять соответствующие действия. Он представляет собой шаблонный класс, где параметры TPort и pinNumber позволяют адаптировать его под конкретный порт и пин микроконтроллера.

Поле currentStatus используется для хранения текущего состояния кнопки, указывая, нажата она или отпущена. Это позволяет отслеживать изменения состояния между последовательными вызовами. Поле buttonPortStatus хранит состояние порта, связанного с кнопкой, что необходимо для анализа сигнала с пина микроконтроллера.

Метод onClick() реализует основную функцию класса. Он проверяет, нажата ли кнопка, анализируя состояние порта, связанного с заданным пином. Если кнопка нажата, метод возвращает true, иначе — false. Этот метод делает класс удобным для обработки событий нажатия кнопки в программной логике микроконтроллера.

Код IModeManager

[source, cpp]
----
#ifndef IMODEMANAGER_H
#define IMODEMANAGER_H

class IModeManager
{
public:
  virtual void InitModeManager() = 0; 
  virtual void UpdateModeManager() = 0; 
  virtual void SwitchModeManager() = 0;
};

#endif
----

Код ModeConfig

[source, cpp]
----
#ifndef MODECONFIG_H
#define MODECONFIG_H

#include "ledconfig.h"
#include "IMode.h"

using tMode = std::array<IMode*, 3>;

#endif
----

Код ModeManager

[source, cpp]
----
#ifndef MODEMANAGER_H
#define MODEMANAGER_H

#include "IModeManager.h"
#include "ModeManagerConfig.h" // for tMode

class ModeManager : public IModeManager
{
public:
  ModeManager(tMode& modes); 
  void InitModeManager() override; 
  void UpdateModeManager() override; 
  void SwitchModeManager() override; 
private:
  tMode& modes; 
  std::uint8_t currentModeType; 
};

#endif
----

Код ModeManager 

[source, cpp]
----
#include "ModeManager.h"

ModeManager::ModeManager(tMode& modeArr) : modes(modeArr), currentModeType(0) 
{
}

void ModeManager::InitModeManager() {
    if (modes[currentModeType]) {
        modes[currentModeType]->Init();
    }
}

void ModeManager::UpdateModeManager() {
    if (modes[currentModeType]) {
        modes[currentModeType]->Update();
    }
}

void ModeManager::SwitchModeManager() {
    currentModeType = (currentModeType + 1) % 3; 
    if (modes[currentModeType]) {
        modes[currentModeType]->Init();
    }
}
----

Далее для реализации переключения режимов необходимо создать класс для кнопки.

=== Класс Button

Кнопка позволяет пользователю взаимодействовать с устройством, выполняя команды или управляя его функциями. С помощью кнопки можно запускается определённое действие или переключается режим работы.

Создадим классы `IButton` и `Button`.

* класс IButton 

[source, cpp]
----
#ifndef IBUTTON_H
#define IBUTTON_H

class IButton {
public:
    virtual bool onClick() = 0;
};
#endif
----

* Класс Button

[source, cpp]
----
#ifndef BUTTON_H
#define BUTTON_H
#include "IButton.h"

template<typename Tport, int punNumber>
class Button : public IButton {
public:
      bool onClick() override
      {
         return (Tport::IDR::Get() & (1 << punNumber)) == 0;
      }
      
private:
  bool currentStatus;
  std::uint32_t buttonPortStatus;
};
#endif
----

Шаблонные параметры Tport и punNumber позволяют настроить класс Button для работы с определёнными портами и пинами. Метод Get() из Tport::IDR используется, чтобы узнать состояние порта и проверить, есть ли сигнал на выбранном пине.

=== Итог работы с классами

Добавление классов в программу на C++ помогает сделать код понятным, разделить задачи между компонентами и упростить его поддержку. В заголовочных файлах описываются интерфейсы классов, а в файлах реализации прописываются их методы. Класс ModeManager управляет режимами работы системы, предоставляя методы для их настройки, обновления и переключения. Режимы хранятся в массиве указателей на объекты, что упрощает добавление новых режимов.

Также был создан класс Button, который позволяет пользователю управлять устройством. Этот класс проверяет, нажата ли кнопка, и запускает нужное действие. Это важно для управления функциями устройства через действия пользователя.

== Настройка тактирования платы

Тактирование в микроконтроллерах, таких как STM32F411RET6, отвечает за установку частоты работы процессора, периферии и других блоков устройства.

Встроенный высокоскоростной осциллятор (HSI) генерирует частоту (обычно 16 или 32 МГц) без внешних компонентов, что удобно для базовых задач и быстрого запуска.

Внешний кварцевый генератор (HSE) обеспечивает более точную и стабильную частоту, например 8 или 16 МГц, что важно для задач, где нужна высокая точность.

Фазовый автоподстройщик частоты (PLL) увеличивает частоту HSI или HSE до нужного уровня, позволяя гибко настроить систему под разные задачи.

Настройка тактирования важна для стабильной работы процессора, памяти, периферии и подключения внешних устройств. Она требует учета совместимости частот и эффективного использования ресурсов микроконтроллера.

=== Пример кода HSI

[source, cpp]
----
std::uint32_t SystemCoreClock = 16'000'000U;

extern "C" 
int __low_level_init(void)

  //Switch on external 16 MHz oscillator
  RCC::CR::HSION::On::Set();
  while (RCC::CR::HSIRDY::NotReady::IsSet())
  {

  }
  //Switch system clock on external oscillator
  RCC::CFGR::SW::Hsi::Set();
  while (!RCC::CFGR::SWS::Hsi::IsSet())
  {

  }
  STK::CTRL::CLKSOURCE::CpuClock::Set();
  RCC::APB2ENR::SYSCFGEN::Enable::Set();

  return 1;
----

Этот код инициализирует микроконтроллер, включая внутренний генератор HSI (16 МГц) и настраивая его как источник системного тактирования. Он ожидает готовности генератора, переключает систему на HSI, настраивает таймер SysTick для работы с тактовым сигналом процессора и включает блок SYSCFG для доступа к системным настройкам. В конце возвращается успешный результат инициализации.

=== Пример кода HSE

[source, cpp]
----
std::uint32_t SystemCoreClock = 8'000'000U;

extern "C" 
int __low_level_init(void)

  //Switch on external 8 MHz oscillator
  RCC::CR::HSEON::On::Set();
  while (RCC::CR::HSERDY::NotReady::IsSet())
  {

  }
  //Switch system clock on external oscillator
  RCC::CFGR::SW::Hse::Set();
  while (!RCC::CFGR::SWS::Hse::IsSet())
  {

  }
  STK::CTRL::CLKSOURCE::CpuClock::Set();
  RCC::APB2ENR::SYSCFGEN::Enable::Set();

  return 1;
----

Здесь включается внешний кварцевый генератор (HSE) с частотой 8 МГц. Код ожидает, пока генератор станет готовым к работе, проверяя флаг готовности HSERDY. Это необходимо для стабильного тактирования системы.

После включения генератора микроконтроллер переключает системный тактовый сигнал на внешний источник (HSE). Код ожидает подтверждения успешного переключения, проверяя флаг состояния SWS.

Здесь SysTick (системный таймер) настраивается на использование тактового сигнала процессора. Это позволяет создавать интервалы времени и использовать таймерные функции.

Включается тактирование блока SYSCFG, который отвечает за работу системных функций, таких как GPIO, настройка прерываний и другие системные конфигурации. Это необходимо для доступа к дополнительным функциям микроконтроллера.

=== Задание на PLL

PLL (Phase-Locked Loop) — это система для изменения частоты тактирования в микроконтроллерах, таких как STM32F411RET6. Она берет частоту внутреннего (HSI) или внешнего (HSE) генератора и умножает её или делит, чтобы получить нужную частоту.

PLL используется, когда исходной частоты HSI или HSE недостаточно, например, для работы с высокими частотами. Это позволяет гибко настроить частоту процессора и периферийных устройств, подстраивая производительность и энергопотребление под задачи системы.

f = f(hse) × (PLLN / PLLM) /PLLP

где: PLLM – делитель входной частоты; PLLN – множитель; PLLP – делитель на выходе PLL.

Для получения частоты 

f = 13.666МГц, например, выберем: PLLM = 8; PLLN = 137; PLLP = 8.

 Проверка f = 137 × 8 / 8 / 8 = 13.666 МГц.


[source, cpp]
----
std::uint32_t SystemCoreClock = 13'666'000U;

extern "C" 
int __low_level_init(void) {

    RCC::CR::HSEON::On::Set();
    while (!RCC::CR::HSERDY::Ready::IsSet()) {
   
    }

    RCC::PLLCFGR::PLLSRC::HseSource::Set();
    // 137
    RCC::PLLCFGR::PLLN0::Set(0b10001001);
    // 8
    RCC::PLLCFGR::PLLP0::Set(0b11);
  
    // 8
    RCC::PLLCFGR::PLLM0::Set(0b001000);

    RCC::CR::HSION::Off::Set();

    RCC::CR::PLLON::On::Set();
    while (RCC::CR::PLLRDY::Unclocked::IsSet()) {
    }

    RCC::CFGR::SW::Pll::Set();
    while (!RCC::CFGR::SWS::Pll::IsSet()) {

     }

    RCC::APB2ENR::SYSCFGEN::Enable::Set();

    return 1;
}
----

=== Вывод

Разработка программы с использованием классов на C++ позволяет эффективно организовать код, улучшая его читаемость и поддержку. Пример с классами ModeManager и Button показывает, как можно реализовать гибкую систему управления режимами устройства и взаимодействие с пользователем. Использование интерфейсов и шаблонов позволяет легко добавлять новые функциональные возможности, следуя принципам объектно-ориентированного программирования, таким как расширяемость и инкапсуляция. Это упрощает не только разработку, но и тестирование различных частей программы.

Кроме того, настройка тактирования микроконтроллера, включая работу с HSI, HSE и PLL, является важным этапом для обеспечения стабильной и точной работы системы. Этот процесс позволяет оптимизировать производительность и энергопотребление устройства в зависимости от конкретных задач. Примеры настройки тактирования и переключения источников частоты демонстрируют, как можно гибко настраивать работу микроконтроллера STM32F411RET6 для различных нужд, обеспечивая при этом высокую точность и стабильность работы всех его компонентов.