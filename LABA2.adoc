= Отчет по лабораторной работе.
Волбенко Валентин дмитриевич
:imagesdir: pic2
:toc:
:toc-title: Оглавление
:toclevels: 4
:figure-caption: Рисунок
:table-caption: Таблица

==  Какие бывают типы
 
Типы данных делятся на три группы, представлены (рисунок <<pic7>>).

.Типы данных в С++
[#pic7]
image::Рисунок 1.png[]

Размеры типов данных в C++ зависят от платформы, архитектуры и компилятора.
На микроконтроллерах, таких как STM32, стандартные типы данных (например, int, float, double) могут иметь различные размеры, определяемые архитектурой ARM Cortex и настройками компилятора.
Давайте разберем, как вычисляется размер типов данных и какие размеры типы могут иметь на микроконтроллерах STM32.

=== Как вычисляется размер типов данных в C++

Размеры типов данных можно получить с помощью оператора sizeof, который возвращает размер типа в байтах. 
Например:
[.source, cpp]
----
#include <iostream>

int main() {
    std::cout << "Размер int: " << sizeof(int) << " байт" << std::endl;
    std::cout << "Размер float: " << sizeof(float) << " байт" << std::endl;
    std::cout << "Размер double: " << sizeof(double) << " байт" << std::endl;
    return 0;
}
----

=== Размеры типов данных для STM32

Микроконтроллеры STM32 основаны на архитектуре ARM Cortex-M, которая поддерживает 32-битные инструкции и регистры.
Стандартные размеры типов данных для микроконтроллеров STM32 обычно следующие:

[horizontal]
|=====================
|Тип данных|	Размер для STM32 (ARM Cortex-M)|	Описание
|bool|	1 байт|	Символ
|signed char|	1 байт|	Знаковое целое
|unsigned char|	1 байт|	Беззнаковое целое
|short|	2 байта|	Знаковое целое
|unsigned short|	2 байта|	Беззнаковое целое
|int|	4 байта|	Знаковое целое
|unsigned int|	4 байта|	Беззнаковое целое
|long|	4 байта|	Знаковое целое
|unsigned long|	4 байта	|Беззнаковое целое
|long long|	8 байт|	Знаковое целое (64 бита)
|unsigned long long|	8 байт|	Беззнаковое целое (64 бита)
|float|	4 байта|	Число с плавающей запятой одинарной точности
|double|	8 байт| (но часто 4 на STM32F)	Число с плавающей запятой двойной точности
|long double|	8 байт|	Число с плавающей запятой двойной точности
|void*|	4 байта	|Указатель
|=====================

== Почему нельзя типы смешивать между собой

Смешивание типов данных в C++ может привести к различным проблемам. Вот основные причины, по которым это не рекомендуется:

. Ошибки компиляции.
. Неопределенное поведение.
. Проблемы с производительностью.
. Потеря информации.
. Сложности в поддержке и отладке.
. Неявные преобразования.
. Нарушение принципов ООП.

== Что такое неявное преобразование типов
 
Неявное преобразование типов — это процесс, при котором компилятор автоматически преобразует один тип данных в другой, когда это необходимо для выполнения операции.

Базовые/простые типы неявно можно привести друг к другу. Т.е
[.source, cpp]
----
int a = 0; # <1>

char a = 512; # <2>

int a = 3.14;  # <3>

bool a = -4;  # <4>

bool a  = 0;  # <5>
----
<1> Присваимаем знаковое целое(int) число переменной целого типа
<2> Присваиваем знаковое целое(int) число переменной типа char. Результат в а 0 ;
<3> Присваиваем число с плавающей точкой(double) к переменной типа int. Результат в а 3
<4> Присваиваем знаковое целое(int) к переменной типа bool. Результат в а true
<5> Присваиваем знаковое целое(int) к переменной типа bool. Результат в а false

== Что такое явное преобразование типов

Так как компилятор может сделать за вас, то, что вы вообще не ожидаете, не нужно использовать неявное
преобразование типа.

Вместо этого, лучше указать компилятору явное преобразование из одного типа в другой.
В этом случае, вы говорите компилятору, что я понимаю, что я делаю, это именно так и задумано

Для преобразований из одного типа используют 4 вариантов преобразования:

* static_cast
* const_cast
* reinterpret_cast
* dynamic_cast

=== static_cast

*static_cast* позволяет сделать приведение близких типов (целые, пользовательских типов которые могут
создаваться из типов который приводится, и указатель на void* к указателю на любой тип).

Проверка производится на уровне компиляции, так что в случае ошибки сообщение будет получено в момент
сборки приложения или библиотеки.
[.source, cpp]
----
int a = static_cast<int>(0); # <1>

int a = static_cast<int>(3.14);  # <2>

bool a = static_cast<bool>(-4);  # <3>

bool a  = static_cast<bool>(0);  # <4>

float f = 3.14f ;     # <5>

float f = static_cast<float>(3.14) ;  # <6>

Complex f = static_cast<3.14> #<7>
----
[.notes]
--

<1> Явно говорим, что 0 должен восприниматься как тип (int), хотя он и так является литералом типа int.
Но все ли помнят об этом?
<2> Явно говорим, что 3.14 воспринимать как int, т.е взять только целую часть.
<3> Явно говорим, -4 нужно воспринять как bool тип, в данном случае true.
<4> Явно говорим, 0 нужно воспринять как bool тип, в данном случае false.
<5> Явно говорим, что 3.14 это float
<6> Явно говорим, что 3.14 это float
<7> Комплексное число может создаться из double, поэтому тут будет работать static_cast.

--

=== reinterpret_cast
*reinterpret_cast* преобразует типы, несовместимыми друг с другом, и используется для:

* В свой собственный тип
* Указателя в интегральный тип
* Интегрального типа в указатель
* Указателя одного типа в указатель другого типа
* Указателя на функцию одного типа в указатель на функцию другого типа

[.source, cpp]
----
auto ptr = reinterpret_cast<volatile uint32_t *>(0x40010000) ; # <1>
auto value = *ptr ; #<2>
----

<1> Преобразует адрес 0x40010000 в указатель типа volatile uint32_t
<2> Записывает в переменную value (типа) значение лежащее по указателю ptr, указывающего на адрес
0x40010000

== Размеры типов
Размеры типов не четко определены и могут отличаться для различных микроконтроллеров.
Поэтому вместо прямых типов типа int, используйте псевдонимы, например:
[horizontal]
|=====================
|std::uint32_t| целое беззнаковое длиной 32 бита
|std::int64_t|  целое знаковое длинной 64 бита
|std::uint8_t| целое знаковое длинной 8 бит
|std::uint16_t|	беззнаковое целое длиной 16 бит
|std::uint32_t|	беззнаковое целое длиной 32 бита
|std::uint64_t|	беззнаковое целое длиной 64 бита
|std::int64_t|	знаковое целое длиной 64 бита
|std::uint8_t|	беззнаковое целое длиной 8 бит
|std::int8_t|	знаковое целое длиной 8 бит
|std::size_t|	беззнаковый тип для размеров объектов
|std::intptr_t	|знаковое целое для хранения указателей
|std::uintptr_t|	беззнаковое целое для хранения указателей
|=====================
== Почему использование встроенных типов плохо

Использование встроенных типов имеет свои преимущества, но есть и недостатки, особенно в сложных проектов или больших приложений. Рассмотрим причины, почему использование встроенных типов плохо:

. Отсутствие безопасности типов.
. Проблемы с точностью.
. Отсутствие семантики.
. Маленький объем информации.
. Отсутствие функций и методов.
. Трудности с поддержкой и расширением.
. Управление памятью.

== Как распределяется память ОЗУ в микроконтроллере

Основные аспекты распределения памяти в микроконтроллерах включают следующие сегменты:

.  Разделение памяти:
* Статическая память: память для переменных,Стек.
* Динамическая память.
. Сегменты памяти.
. Области памяти.
. Обратная совместимость и управление.
. Проблемы с памятью.

== Указатель
Данные могут находится в ОЗУ или ПЗУ. Каждой переменной содержащей данные соответствует некоторый адрес памяти. К переменной можно обратиться непосредственно обращаясь к самой переменной, тогда мы можем напрямую писать или читать значение с адреса переменной, либо можно обратиться косвенно, через указатель или ссылку.

*Указатель* - это переменная, которая хранит адрес другой переменной.

=== Взятие адреса и разыменование указателя.

Для того чтобы узнать адрес переменной, используется оператор взятия адреса _&_ +

.Пример:
[source, cpp, linenums]

----
char* Ptr = &a;
----

<<<

WARNING: Тип указателя должен совпадать с типом переменной!

*Разыменовывание* - обратная операция операции взятия адреса, которая выводит значение, хранимое по адресу указанному в указателе.

=== Операции над указателями

Указатели можно складывать, вычитать, сравнивать. Но указатели должны быть одного типа.
Над указателями можно выполнять арифметические операции сложения, инкремента (увеличения на 1), вычитания, декремента (уменьшения на 1) и операции сравнения (>, >=, <, <=, ==, !=). При выполнении арифметических операций с указателями автоматически учитывается размер данных, на которые он указывает.
При вычитании одного указателя из другого, нужно придерживаться важных правил:

. Указатели должны указывать на один массив:
Вычитание возможно только если оба указателя относятся к одному и тому же массиву или диапазону памяти. Если они из разных массивов, это приведет к ошибкам.

. Результат — количество элементов:
Вычитание дает разницу в количестве элементов, а не в байтах. Например, если вычесть указатель на первый элемент массива из указателя на последний, вы получите количество элементов между ними.

. Тип результата:
Результат вычитания — это тип ptrdiff_t, который может хранить целые числа, представляющие разницу в элементах.

Пример:

[.source, cpp]
----
int arr[5] = {10, 20, 30, 40, 50};
int* ptr1 = &arr[4];  // Указатель на 5-й элемент
int* ptr2 = &arr[0];  // Указатель на 1-й элемент

ptrdiff_t diff = ptr1 - ptr2;  // Разница: 4
----
Вычитать один указатель из другого можно, если они указывают на элементы одного массива или диапазона памяти. Это дает разницу в количестве элементов, а не байтов.

Указатели можно сравнивать, причём не, только на равенство или неравенство, ведь адреса могут быть меньше или больше относительно друг друга.

Чтобы изменить значение в любой ячейке памяти, нужно использовать указатель. Пример:

* Создадим переменную и получим её адрес:

[.source, cpp]
----
#include <iostream>
int num = 10;
int* prt = & num; //Указатель на переменную num
----

* Изменим значение по этому адресу:

[.source, cpp]
----
#include <iostream>
*ptr = 20; //Изменим значение num на 20
----

== Адрес указателя при прибавлении единицы

=== Указатель типа int
Если указатель типа int указывает на адрес 1 и к нему прибавить 1, то новый адрес будет зависеть от размера типа int. В большинстве современных систем размер int равен 4 байтам (32 бита). При прибавлении 1 к указателю происходит смещение на 1 элемент типа int, что равняется 4 байтам. Следовательно, указатель будет указывать на адрес 5 (1 + 4 = 5).

=== Указатель типа double
Размер типа double обычно составляет 8 байт. Если указатель типа double указывает на адрес 1, то при прибавлении 1 к указателю произойдет смещение на 8 байт. Указатель будет указывать на адрес 9 (1 + 8 = 9).

== Что будет в переменной b для указателя на std::uint32_t

Если у нас есть память с числами:

* по адресу 1 — 10,
* по адресу 2 — 20,
* по адресу 3 — 30,
* по адресу 4 — 40,

и указатель типа std::uint32_t указывает на адрес 1, то:
[.source, cpp]
----
std::uint32_t* ptr = reinterpret_cast<std::uint32_t*>(1);
auto b = *ptr;
----
std::uint32_t — это 32-битное (4 байта) целое число. А память читается по 4 байта,то адрес 1 не выровнен для 32-битного доступа, что может вызвать неопределенное поведение, но если представить это как 32-битный доступ с адреса 1, то будет считано 4 байта по адресам с 1 по 4:

* байт по адресу 1 = 10,
* байт по адресу 2 = 20,
* байт по адресу 3 = 30,
* байт по адресу 4 = 40.

Значение b будет 0x28201E0A в шестнадцатеричной системе или 673720842 в десятичной.

=== Порядок байтов 

Little Endian — младшие байты числа находятся в младших адресах. При чтении std::uint32_t с адреса 1 в Little Endian порядок будет:

[.source, cpp]
----
байт по адресу 1 (0x0A) -> младший байт
байт по адресу 2 (0x14)
байт по адресу 3 (0x1E)
байт по адресу 4 (0x28) -> старший байт
----
Little Endian значении b = 0x28201E0A (или 673720842 в десятичной системе).

Big Endian — старшие байты числа находятся в младших адресах. В Big Endian порядок байтов будет:

[.source, cpp]
----
байт по адресу 1 (0x0A) -> старший байт
байт по адресу 2 (0x14)
байт по адресу 3 (0x1E)
байт по адресу 4 (0x28) -> младший байт
----
В Big Endian значении b = 0x0A1E1428 (или 169745576 в десятичной системе).

== Что будет в переменной b для указателя на std::uint16_t

Если указатель теперь типа std::uint16_t:
[.source, cpp]
----
std::uint16_t* ptr = reinterpret_cast<std::uint16_t*>(1);
auto b = *ptr;
----

std::uint16_t — это 16-битное (2 байта) целое число. При разыменовании указателя, будет прочитано 2 байта, начиная с адреса 1:

* байт по адресу 1 = 10,
* байт по адресу 2 = 20.

Значение b будет 0x140A в шестнадцатеричной системе или 5130 в десятичной.

== Регистр

Регистр — это небольшая ячейка памяти, расположенная в процессоре, предназначенная для хранения данных, с которыми процессор выполняет операции. Регистры используются для хранения промежуточных данных, адресов и инструкций.

Как изменить значение регистра переменной.Для обычных переменных в C++ изменение значения происходит просто через присваивание:
[.source, cpp]
----
sint x = 10;
x = 20; // Значение переменной изменилось на 20
----

== Что такое дизъюнкция и конъюнкция 

=== Дизъюнкция
Дизъюнкция — это логическая операция ИЛИ (OR), которая возвращает true, если хотя бы один из операндов истинный.

=== Конъюнкция 
Конъюнкция — это логическая операция И (AND), которая возвращает true, если оба операнда истинны.

== Как сбросить бит

Сбросить бит — значит установить его значение в 0. Для этого можно использовать побитовую операцию И с побитовой инверсией:
[.source, cpp]
----
x = x & (~(1 << n));
----
Где:

* x — это число, в котором нужно сбросить бит.
* n — номер бита, который нужно сбросить (нумерация обычно начинается с 0).
* 1 << n — это сдвиг числа 1 на n позиций влево, что создает маску для нужного бита.
* ~(1 << n) — инвертирует маску, чтобы все биты были 1, кроме n-го бита, который будет 0.
* x & ~(...) — с помощью побитового И сбрасывается нужный бит.

== Тип переменной b

[.source, cpp]
----
auto b = "c";
----
Переменная b будет типа const char* (указатель на константную строку), потому что строка в C++ заключенная в двойные кавычки ("c") интерпретируется как массив символов, который автоматически преобразуется в указатель на первый элемент массива.

== Тип переменной b1

[.source, cpp]
----
auto b1 = 'c';
----

Переменная b1 будет типа char, так как символ, заключенный в одинарные кавычки ('c'), представляет собой одиночный символ.

== Перевод символа 'A' в число

[.source, cpp]
----
char a = 'A';
----

Символ 'A' будет переведён в числовое значение, соответствующее его ASCII-коду. В ASCII-коде символ 'A' имеет значение 65.

== Вывод
В данной практической рабете, были привиденны какие бывают типы данных, почему нельзя их смешивать между собой. Расмотрел, что такое неявное и явное преобразование типов, размеры типов, почему использование встроенных типов плохо, как распределяется память ОЗУ в микроконтроллере, что такое указатель, что можно делать с указателем и как изменить любую ячейку памяти.