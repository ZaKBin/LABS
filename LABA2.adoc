= Отчет по лабораторной работе.
Волбенко Валентин дмитриевич
:imagesdir: pic2
:toc:
:toc-title: Оглавление
:toclevels: 4
:figure-caption: Рисунок
:table-caption: Таблица

==  Какие бывают типы
 
Типы данных делятся на три группы, представлены (рисунок <<pic7>>).

.Типы данных в С++
[#pic7]
image::Рисунок 1.png[]
 
== Почему нельзя типы смешивать между собой

Смешивание типов данных в C++ может привести к различным проблемам. Вот основные причины, по которым это не рекомендуется:

. Ошибки компиляции.
. Неопределенное поведение.
. Проблемы с производительностью.
. Потеря информации.
. Сложности в поддержке и отладке.
. Неявные преобразования.
. Нарушение принципов ООП.

== Что такое неявное преобразование типов
 
Неявное преобразование типов — это процесс, при котором компилятор автоматически преобразует один тип данных в другой, когда это необходимо для выполнения операции.

Базовые/простые типы неявно можно привести друг к другу. Т.е
[.source, cpp]
----
int a = 0; # <1>

char a = 512; # <2>

int a = 3.14;  # <3>

bool a = -4;  # <4>

bool a  = 0;  # <5>
----
<1> Присваимаем знаковое целое(int) число переменной целого типа
<2> Присваиваем знаковое целое(int) число переменной типа char. Результат в а 0 ;
<3> Присваиваем число с плавающей точкой(double) к переменной типа int. Результат в а 3
<4> Присваиваем знаковое целое(int) к переменной типа bool. Результат в а true
<5> Присваиваем знаковое целое(int) к переменной типа bool. Результат в а false

== Что такое явное преобразование типов

Так как компилятор может сделать за вас, то, что вы вообще не ожидаете, не нужно использовать неявное
преобразование типа.

Вместо этого, лучше указать компилятору явное преобразование из одного типа в другой.
В этом случае, вы говорите компилятору, что я понимаю, что я делаю, это именно так и задумано

Для преобразований из одного типа используют 4 вариантов преобразования:

* static_cast
* const_cast
* reinterpret_cast
* dynamic_cast

=== static_cast

*static_cast* позволяет сделать приведение близких типов (целые, пользовательских типов которые могут
создаваться из типов который приводится, и указатель на void* к указателю на любой тип).

Проверка производится на уровне компиляции, так что в случае ошибки сообщение будет получено в момент
сборки приложения или библиотеки.
[.source, cpp]
----
int a = static_cast<int>(0); # <1>

int a = static_cast<int>(3.14);  # <2>

bool a = static_cast<bool>(-4);  # <3>

bool a  = static_cast<bool>(0);  # <4>

float f = 3.14f ;     # <5>

float f = static_cast<float>(3.14) ;  # <6>

Complex f = static_cast<3.14> #<7>
----
[.notes]
--
<1> Явно говорим, что 0 должен восприниматься как тип (int), хотя он и так является литералом типа int.
Но все ли помнят об этом?
<2> Явно говорим, что 3.14 воспринимать как int, т.е взять только целую часть.
<3> Явно говорим, -4 нужно воспринять как bool тип, в данном случае true.
<4> Явно говорим, 0 нужно воспринять как bool тип, в данном случае false.
<5> Явно говорим, что 3.14 это float
<6> Явно говорим, что 3.14 это float
<7> Комплексное число может создаться из double, поэтому тут будет работать static_cast.
--

=== reinterpret_cast
*reinterpret_cast* преобразует типы, несовместимыми друг с другом, и используется для:

* В свой собственный тип
* Указателя в интегральный тип
* Интегрального типа в указатель
* Указателя одного типа в указатель другого типа
* Указателя на функцию одного типа в указатель на функцию другого типа

[.source, cpp]
----
auto ptr = reinterpret_cast<volatile uint32_t *>(0x40010000) ; # <1>
auto value = *ptr ; #<2>
----

<1> Преобразует адрес 0x40010000 в указатель типа volatile uint32_t
<2> Записывает в переменную value (типа) значение лежащее по указателю ptr, указывающего на адрес
0x40010000

== Размеры типов
Размеры типов не четко определены и могут отличаться для различных микроконтроллеров.
Поэтому вместо прямых типов типа int, используйте псевдонимы, например:
[horizontal]
|=====================
|std::uint32_t| целое беззнаковое длиной 32 бита
|std::int64_t|  целое знаковое длинной 64 бита
|std::uint8_t| целое знаковое длинной 8 бит
|=====================

== Почему использование встроенных типов плохо

Использование встроенных типов имеет свои преимущества, но есть и недостатки, особенно в сложных проектов или больших приложений. Рассмотрим причины, почему использование встроенных типов плохо:

. Отсутствие безопасности типов.
. Проблемы с точностью.
. Отсутствие семантики.
. Маленький объем информации.
. Отсутствие функций и методов.
. Трудности с поддержкой и расширением.
. Управление памятью.

== Как распределяется память ОЗУ в микроконтроллере

Основные аспекты распределения памяти в микроконтроллерах включают следующие сегменты:

.  Разделение памяти:
* Статическая память: память для переменных,Стек.
* Динамическая память.
. Сегменты памяти.
. Области памяти.
. Обратная совместимость и управление.
. Проблемы с памятью.

== Указатель
Данные могут находится в ОЗУ или ПЗУ. Каждой переменной содержащей данные соответствует некоторый адрес памяти. К переменной можно обратиться непосредственно обращаясь к самой переменной, тогда мы можем напрямую писать или читать значение с адреса переменной, либо можно обратиться косвенно, через указатель или ссылку.

*Указатель* - это переменная, которая хранит адрес другой переменной.

=== Взятие адреса и разыменование указателя.

Для того чтобы узнать адрес переменной, используется оператор взятия адреса _&_ +

.Пример:
[source, cpp, linenums]

----
char* Ptr = &a;
----

<<<

WARNING: Тип указателя должен совпадать с типом переменной!

*Разыменовывание* - обратная операция операции взятия адреса, которая выводит значение, хранимое по адресу указанному в указателе.

=== Операции над указателями
Указатели можно складывать с целым числом, вычитать, сравнивать. Но указатели должны быть одного типа. 

==== Сложение/Вычитание
При прибавлении к указателю числа адрес переменной, который хранит данный указатель, увеличивается на размерность типа указателя.

*Инкрементирование* - сложение указателей.
*Дикрементирование* - вычитание указателей.

==== Сравнение указателей
Сравнение указателей является фактическим сравнением адресов, переменных. 

[IMPORTANT]
Нельзя сравнивать указатели разных типов!

WARNING: Компилятор не умеет работать с нулевым указателем

=== Как изменить любую ячейку памяти

С помощью указаеля ptr, можно изменить любую ячейку памяти

[.source, cpp]
----
#include <iostream>

int main() {
    int value = 42; // Инициализация переменной
    int* ptr = &value; // Получаем адрес переменной

    std::cout << "Исходное значение: " << value << std::endl;

    // Изменяем значение через указатель
    *ptr = 100; // Изменяем значение по адресу, на который указывает ptr

    std::cout << "Измененное значение: " << value << std::endl;

    return 0;
}
----

== Адрес указателя при прибавлении единицы

=== Указатель типа int
Если указатель типа int указывает на адрес 1 и к нему прибавить 1, то новый адрес будет зависеть от размера типа int. В большинстве современных систем размер int равен 4 байтам (32 бита). При прибавлении 1 к указателю происходит смещение на 1 элемент типа int, что равняется 4 байтам. Следовательно, указатель будет указывать на адрес 5 (1 + 4 = 5).

=== Указатель типа double
Размер типа double обычно составляет 8 байт. Если указатель типа double указывает на адрес 1, то при прибавлении 1 к указателю произойдет смещение на 8 байт. Указатель будет указывать на адрес 9 (1 + 8 = 9).

== Что будет в переменной b для указателя на std::uint32_t

Если у нас есть память с числами:

* по адресу 1 — 10,
* по адресу 2 — 20,
* по адресу 3 — 30,
* по адресу 4 — 40,

и указатель типа std::uint32_t указывает на адрес 1, то:
[.source, cpp]
----
std::uint32_t* ptr = reinterpret_cast<std::uint32_t*>(1);
auto b = *ptr;
----
std::uint32_t — это 32-битное (4 байта) целое число. А память читается по 4 байта,то адрес 1 не выровнен для 32-битного доступа, что может вызвать неопределенное поведение, но если представить это как 32-битный доступ с адреса 1, то будет считано 4 байта по адресам с 1 по 4:

* байт по адресу 1 = 10,
* байт по адресу 2 = 20,
* байт по адресу 3 = 30,
* байт по адресу 4 = 40.

Значение b будет 0x28201E0A в шестнадцатеричной системе или 673720842 в десятичной.

== Что будет в переменной b для указателя на std::uint16_t

Если указатель теперь типа std::uint16_t:
[.source, cpp]
----
std::uint16_t* ptr = reinterpret_cast<std::uint16_t*>(1);
auto b = *ptr;
----

std::uint16_t — это 16-битное (2 байта) целое число. При разыменовании указателя, будет прочитано 2 байта, начиная с адреса 1:

* байт по адресу 1 = 10,
* байт по адресу 2 = 20.

Значение b будет 0x140A в шестнадцатеричной системе или 5130 в десятичной.

== Регистр

Регистр — это небольшая ячейка памяти, расположенная в процессоре, предназначенная для хранения данных, с которыми процессор выполняет операции. Регистры используются для хранения промежуточных данных, адресов и инструкций.

Как изменить значение регистра переменной.Для обычных переменных в C++ изменение значения происходит просто через присваивание:
[.source, cpp]
----
sint x = 10;
x = 20; // Значение переменной изменилось на 20
----

== Что такое дизъюнкция и конъюнкция 

=== Дизъюнкция
Дизъюнкция — это логическая операция ИЛИ (OR), которая возвращает true, если хотя бы один из операндов истинный.

=== Конъюнкция 
Конъюнкция — это логическая операция И (AND), которая возвращает true, если оба операнда истинны.

== Как сбросить бит

Сбросить бит — значит установить его значение в 0. Для этого можно использовать побитовую операцию И с побитовой инверсией:
[.source, cpp]
----
x = x & (~(1 << n));
----
Где:

* x — это число, в котором нужно сбросить бит.
* n — номер бита, который нужно сбросить (нумерация обычно начинается с 0).
* 1 << n — это сдвиг числа 1 на n позиций влево, что создает маску для нужного бита.
* ~(1 << n) — инвертирует маску, чтобы все биты были 1, кроме n-го бита, который будет 0.
* x & ~(...) — с помощью побитового И сбрасывается нужный бит.

== Тип переменной b

[.source, cpp]
----
auto b = "c";
----
Переменная b будет типа const char* (указатель на константную строку), потому что строка в C++ заключенная в двойные кавычки ("c") интерпретируется как массив символов, который автоматически преобразуется в указатель на первый элемент массива.

== Тип переменной b1

[.source, cpp]
----
auto b1 = 'c';
----

Переменная b1 будет типа char, так как символ, заключенный в одинарные кавычки ('c'), представляет собой одиночный символ.

== Перевод символа 'A' в число

[.source, cpp]
----
char a = 'A';
----

Символ 'A' будет переведён в числовое значение, соответствующее его ASCII-коду. В ASCII-коде символ 'A' имеет значение 65.

== Вывод
В данной практической рабете, были привиденны какие бывают типы данных, почему нельзя их смешивать между собой. Расмотрел, что такое неявное и явное преобразование типов, размеры типов, почему использование встроенных типов плохо, как распределяется память ОЗУ в микроконтроллере, что такое указатель, что можно делать с указателем и как изменить любую ячейку памяти.