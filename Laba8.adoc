= Лабораторная работа №8
Волбенко В.Д. <КЭ-413>
:description: Лабораторная работа №8
:toc:
:toc-title: Оглавление
:imagesdir: Pic
:figure-caption: Рисунок
:table-caption: Таблица

include::Titul7.adoc[]

== Основные характеристики АЦП

Аналого-цифровой преобразователь (АЦП) — электронное устройство, преобразующее напряжение в двоичный цифровой код. Тем не менее, некоторые неэлектронные устройства с цифровым выходом следует также относить к АЦП, например, некоторые типы преобразователей угол-код. Простейшим одноразрядным двоичным АЦП является компаратор.

АЦП в микроконтроллерах STM32F4 (включая модель STM32F411) представляет собой встроенный периферийный модуль, предназначенный для преобразования аналоговых сигналов в цифровые значения. В основе работы этого модуля лежит метод последовательного приближения (SAR), который поэтапно сравнивает входное напряжение с опорным значением и уточняет результат от старших разрядов к младшим.

Основные характеристики АЦП в STM32F411:

. Разрядность : 12 бит, что соответствует диапазону значений от 0 до 4095. При опорном напряжении 3.3 В шаг квантования составляет около 0.8–1 мВ на один бит (точная величина зависит от режима работы и конфигурации).

. Диапазон измерений : от 0 В (VSSA) до VDDA (обычно 3.3 В). Для корректной работы важно соблюдать условия питания и не превышать указанные пределы.

. Скорость работы : максимальная тактовая частота АЦП достигает 36 МГц. В 12-битном режиме теоретически возможна скорость оцифровки до 2.4 миллиона выборок в секунду (MSPS) при минимальном времени выборки.

. Многоканальность : АЦП поддерживает работу с несколькими каналами (до 19), включая 16 внешних и 3 внутренних (датчик температуры, встроенный источник опорного напряжения VREFINT и измерение напряжения резервной батареи VBAT).

. Режимы работы : доступны различные режимы преобразования, такие как одиночное измерение, непрерывное преобразование, сканирование нескольких каналов последовательно или разбиение их на группы.

. Триггеры запуска : преобразование может быть инициировано программно (через бит SWSTART) или аппаратно (например, сигналами от таймеров или внешними событиями).

. Поддержка DMA : результаты преобразования могут передаваться в память напрямую через контроллер DMA, минуя центральный процессор.

. Аналоговый сторож (Analog Watchdog): позволяет отслеживать выход результата за заданные пороги и вызывать соответствующее событие или прерывание.

Благодаря этим характеристикам АЦП в STM32F4 является мощным инструментом для обработки аналоговых сигналов, будь то данные от внешних датчиков (например, потенциометров) или встроенных источников (таких как датчик температуры или мониторинг напряжения питания). 


== Управляющие регистры

Для настройки и контроля работы АЦП STM32F411 используются специальные регистры. Ниже перечислены основные из них, их назначение и ключевые параметры.

=== ADC_SR (Status Register) – Регистр статуса
Отображает текущее состояние АЦП:

* AWD: Флаг срабатывания аналогового сторожевого таймера (выход за пороги);
* EOC: Флаг завершения одиночного преобразования;
* OVR: Флаг переполнения (если новый результат записан до считывания предыдущего).

=== ADC_CR1 (Control Register 1) – Регистр управления 1
Настройка режимов работы АЦП:

* AWDCH[4:0]: Выбор канала для мониторинга аналоговым сторожевым таймером;
* SCAN: Включение режима сканирования каналов;
* RES[1:0]: Выбор разрядности результата (12, 10, 8 или 6 бит).

=== ADC_CR2 (Control Register 2) – Регистр управления 2

Управление запуском преобразования и дополнительными функциями:

* ADON: Включение/выключение АЦП;
* CONT: Включение непрерывного режима;
* CAL: Запуск калибровки АЦП.;
* SWSTART: Программный запуск преобразования;
* EXTEN[1:0]: Настройка триггера внешнего запуска;
* ALIGN: Выравнивание данных (лево- или право-ориентированное).

=== ADC_SMPR1 и ADC_SMPR2 (Sample Time Registers) – Регистры установки времени дискретизации

Настройка времени выборки для каждого канала:

* SMPx[2:0]: Время выборки для каждого канала (от 3 до 480 тактов АЦП).

=== ADC_SQRx (Regular Sequence Registers) – Регистр определения последовательности преобразований

Определение порядка и количества каналов для регулярной последовательности преобразований.

Регистры :

* ADC_SQR1, ADC_SQR2, ADC_SQR3: Определяют последовательность каналов (до 16 каналов);
* L[3:0] в ADC_SQR1: Количество преобразуемых каналов (от 1 до 16).

=== ADC_DR (Data Register) – Регистр данных

Хранение результата последнего преобразования:

*DATA[15:0]: Результат преобразования (12 бит данных, остальные биты зарезервированы или используются для выравнивания).

=== ADC_CCR (Common Control Register) – Общий регистр управления

Настройка общих параметров для всех АЦП (если их несколько в системе):
* MULTI[4:0]: Режим многоканального преобразования (одиночный, двойной, тройной АЦП);
* DMA: Включение DMA для передачи данных;
* VREFEN: Включение внутреннего опорного напряжения VREFINT;
* VBATE: Включение измерения напряжения на выводе VBAT;
* TSVREFE: Включение датчика температуры.

== Алгоритм запуска однократного преобразования

Процесса настройки и работы АЦП в режиме одиночного преобразования:

. Подготовка тактирования:

* Включите тактирование для АЦП, установив бит ADC1EN в регистре RCC_APB2ENR;
* Если вы используете внешний сигнал (например, с вывода PA0), включите тактирование соответствующего порта GPIO через регистр RCC_AHB1ENR.

. Настройка GPIO:

* Переключите нужный вывод (например, PA0) в аналоговый режим, установив биты 11₂ в регистре GPIOx_MODER.

. Общие настройки АЦП. В регистре ADC_CCR:

* Выберите предделитель частоты (ADCPRE) для АЦП.
* Если нужно измерять температуру или напряжение батареи, включите соответствующие опции (TSVREFE или VBATE).

. Основные параметры АЦП.

* В регистре ADC_CR1:

** Установите разрядность результата (RES=00 для 12 бит); 
** Отключите режим сканирования (SCAN=0).

* В регистре ADC_CR2: 

** Отключите непрерывный режим (CONT=0);
** Выберите выравнивание данных вправо (ALIGN=0);
** Пока не включайте АЦП (ADON=0), чтобы завершить настройку.

. Установка времени выборки:

* В регистрах ADC_SMPR1 или ADC_SMPR2 задайте время выборки для канала. Например:

** Для быстрого сигнала выберите короткое время (15–28 тактов);
** Для медленных сигналов (например, датчик температуры) выберите более длительное время (до 480 тактов).

. Выбор канала:

* В регистре ADC_SQR3 укажите номер канала для измерения (например, SQ1=0 для канала 0);
* В регистре ADC_SQR1 установите L=0, чтобы указать, что нужно измерить только один канал.

. Включение АЦП:

* Включите АЦП, установив бит ADON в регистре ADC_CR2. Подождите несколько микросекунд, чтобы АЦП стабилизировался.

. Запуск преобразования:

* Запустите преобразование, установив бит SWSTART в регистре ADC_CR2.

. Ожидание завершения:

* Проверяйте бит EOC в регистре ADC_SR. Когда он станет равен 1, это значит, что преобразование завершено.

. Чтение результата:

* Считайте результат из регистра ADC_DR. При выравнивании вправо данные находятся в младших 12 битах;
* После чтения бит EOC автоматически сбрасывается.

== Разработка класса для управления АЦП

Чтобы упростить работу с АЦП и скрыть сложные детали настройки регистров, можно создать специальный класс на C++. Этот класс будет отвечать за инициализацию АЦП и предоставит удобные методы для чтения данных с нужного канала, например, readChannel(uint8_t channel).

Ниже приведён пример такого класса (упрощённый, но демонстрирующий основную идею):

[source,cpp]
----
class ADC_Manager
{
public:
    // Конструктор — выполняет базовую настройку АЦП
    ADC_Manager()
    {
        // 1) Включить тактирование АЦП (RCC->APB2ENR |= RCC_APB2ENR_ADC1EN).
        // 2) Настроить общий регистр (ADC->CCR): задать предделитель частоты и при необходимости включить TSVREFE.
        // 3) Настроить параметры в CR1 и CR2: одиночный режим, 12-битное разрешение, выравнивание вправо и т.д.
        // 4) Включить АЦП, установив бит ADON.
    }

    // Метод для чтения значения с указанного канала
    uint16_t readChannel(uint8_t channel)
    {
        // 1) Установить время выборки для выбранного канала (через регистры SMPR1 или SMPR2).
        // 2) Задать номер канала в регистре SQR (L=0, SQ1 = channel).
        // 3) Запустить преобразование, установив бит SWSTART.
        // 4) Дождаться завершения преобразования, проверяя флаг EOC.
        // 5) Прочитать результат из регистра DR и вернуть его.
        return 0; // В реальном коде здесь будет возвращено значение.
    }
};
----

Этот класс объединяет следующие задачи:

. Включение тактирования АЦП.
. Настройку регистров, таких как CR1, CR2, SMPR1/2, SQR и других.
. Запуск и контроль процесса преобразования.

Используя этот класс в программе, достаточно создать объект ADC_Manager adc; и вызывать метод adc.readChannel(номер_канала). В результате будет получено 12-битное значение, которое можно легко преобразовать в напряжение или другие физические величины. Такой подход делает код более читаемым и упрощает его поддержку. Если потребуется изменить настройки АЦП (например, время выборки или разрядность), это можно сделать в одном месте — внутри класса.

== Практические примеры использования АЦП 

=== Измерение температуры (встроенный датчик микроконтроллера)

В микроконтроллере STM32F411 предусмотрен встроенный датчик температуры, подключённый к каналу ADC_IN18. Этот датчик измеряет температуру кристалла микроконтроллера (а не окружающей среды) и обычно применяется для внутреннего мониторинга:

. Включение датчика и настройка времени выборки

* Включить питание датчика температуры и внутреннего опорного напряжения, установить бит TSVREFE в регистре ADC_CCR.
* Для канала 18 задать максимальное время выборки (480 тактов, код 111), так как датчик имеет высокое выходное сопротивление.

. Выбор канала

* В регистре ADC_SQR3 выбрать канал 18 (SQ1=18);
* В регистре ADC_SQR1 установить значение L=0, чтобы указать, что будет выполнено одиночное преобразование.

. Запуск преобразования и чтение результата

* Включить АЦП, установить бит ADON в регистре ADC_CR2;
* Запустить преобразование, установить бит SWSTART;
* Дождаться завершения преобразования, проверять флаг EOC в регистре ADC_SR;
* Прочитать результат из регистра ADC_DR.

. Перевод кода в температуру

В официальной документации (Reference Manual и Datasheet) приведена формула для расчёта температуры с учётом заводской калибровки. Пример линейной интерполяции:

  T = 30°C + ( (Code_measured - TS_CAL1) / (TS_CAL2 - TS_CAL1) ) * (110°C - 30°C)

где:
 * TS_CAL1 — заводской калибровочный код при 30°C;
 * TS_CAL2 — заводской калибровочный код при 110°C.

* Адреса калибровочных значений указаны в документации на микроконтроллер. Эти значения можно считать из памяти для точного расчёта температуры;
* Если точные калибровочные данные недоступны, использовать упрощённую формулу с типовыми параметрами: средний наклон (AvgSlope ~ 2.5 мВ/°C) и напряжение при 25°C (V25 ~ 0.76 В).

Измерение температуры кристалла в STM32F411 легко интегрируется в программу, если соблюдать требования к настройке времени выборки и включению питания датчика. Однако важно помнить, что показания отражают температуру кристалла микроконтроллера, которая может значительно отличаться от температуры окружающей среды.

=== Измерение напряжения на переменном резисторе

Измерение аналогового сигнала с помощью потенциометра (переменного резистора) — это классический пример использования АЦП. Потенциометр обычно подключается между питанием (3.3 В) и землёй, а его средний вывод (ползунок) подсоединяется к входу АЦП:

. Подключение и настройка GPIO

* Убедиться, что выбранный вывод (например, PA0, связанный с каналом 0 АЦП) переведён в аналоговый режим, установив MODER=11₂;
* Включить тактирование порта A, установив бит GPIOAEN в регистре RCC_AHB1ENR.

. Настройка АЦП

.. Включить модуль ADC1, установив бит ADC1EN в регистре RCC_APB2ENR;
.. Настроить разрядность (12 бит), одиночный режим и выравнивание данных вправо через регистры CR1 и CR2;
.. Задать время выборки в регистре SMPR (например, 15 или 28 тактов), если источник имеет низкое выходное сопротивление (потенциометр обычно имеет сопротивление в несколько кОм);
.. Указать канал 0 в регистре SQR3 (установить L=0 и SQ1=0);
.. Включить АЦП, установив бит ADON.

. Выполнение преобразования

* Запустить преобразование, установив бит SWSTART в регистре ADC_CR2;
* Дождаться завершения преобразования, проверяя флаг EOC в регистре ADC_SR;
* Считать результат из регистра ADC_DR.

. Перевод результата в напряжение

Полученное 12-битное значение (диапазон 0…4095) соответствует уровню напряжения от 0 до VREF (обычно 3.3 В). Для перевода в вольты используется формула:

  voltage = (ADC_CODE / 4095.0f) * VREF

Например, при VREF = 3.3 В и коде 2048 напряжение составит примерно 1.65 В (половина диапазона).

Считывая напряжение с ползунка потенциометра, можно легко определить его текущее положение. Этот подход также применим для работы с аналоговыми датчиками, которые выдают сигнал в виде напряжения в диапазоне 0…3.3 В.

== Вывод по работе

Аналого-цифровой преобразователь (АЦП) в микроконтроллерах STM32F411 является мощным и гибким инструментом для обработки аналоговых сигналов. Его основные характеристики, такие как 12-битная разрядность, поддержка до 19 каналов (включая внутренние датчики), высокая скорость работы (до 2.4 MSPS) и различные режимы преобразования, делают его пригодным для широкого спектра задач, от измерения напряжения на внешних устройствах до мониторинга внутренних параметров микроконтроллера.

Для управления АЦП используются специальные регистры, которые позволяют настраивать его работу с высокой точностью. Основные регистры включают:

* ADC_SR для контроля состояния (например, завершение преобразования или выход за пороги);
* ADC_CR1 и ADC_CR2 для настройки режимов работы (разрядность, непрерывный режим, триггеры запуска и т.д.);
* ADC_SMPR1/2 для установки времени выборки;
* ADC_SQRx для определения последовательности каналов;
* ADC_DR для хранения результатов преобразования;
* ADC_CCR для общих настроек (например, включение датчика температуры или DMA).

Процесс однократного преобразования требует последовательной настройки тактирования, GPIO, параметров АЦП и запуска преобразования. Для упрощения работы с АЦП можно разработать класс на C++, который инкапсулирует все низкоуровневые детали, предоставляя удобный интерфейс для чтения данных с нужного канала.

Практические примеры использования АЦП включают:

. Измерение температуры кристалла микроконтроллера : Встроенный датчик температуры позволяет контролировать нагрев микроконтроллера, что важно для предотвращения перегрева и обеспечения стабильной работы.
. Измерение напряжения с потенциометра : Этот классический пример демонстрирует возможность использования АЦП для определения положения ползунка переменного резистора, что может быть применено в системах регулировки или управления.

Таким образом, АЦП в STM32F411 предоставляет широкие возможности для работы с аналоговыми сигналами, а использование классов на C++ значительно упрощает интеграцию АЦП в программу, делая код более читаемым и удобным для поддержки. Однако важно учитывать особенности конкретных задач, такие как время выборки, разрядность и характер сигнала, чтобы достичь максимальной точности и эффективности работы.

[source,cpp]
----
#include "rccregisters.hpp"    // for RCC
#include "gpioaregisters.hpp"  // for GPIOA
#include "gpiocregisters.hpp"  // for GPIOC
#include <array>
#include <cstdint>
#include "adc1registers.hpp"   // for ADC CR1
#include <iostream>

#include "stkregisters.hpp"    // for SystemTimer
#include "scbregisters.hpp"    // for ISCR register
#include "tim2registers.hpp"

#include "ILed.h"
#include "Led.h"
#include "ledconfig.h"

#include "IMode.h"
#include "allmode.h"
#include "treemode.h"
#include "chessmode.h"
#include "modeconfig.h"
#include "IButton.h"
#include "Button.h"
#include "IModeManager.h"
#include "modeconfig.h"
#include "ModeManager.h"
#include "ButtonExti.h"
#include "ModeManagerConfig.h"
#include "syscfgregisters.hpp"
#include "extiregisters.hpp"
#include "nvicregisters.hpp"   // for NVIC
#include "tim5registers.hpp"   // for TIM5

std::uint32_t SystemCoreClock = 8'000'000U;

extern "C" {
int __low_level_init(void)
{
  RCC::CR::HSION::On::Set();
  // while (RCC::CR::HSIRDY::NotReady::IsSet()) { }
  RCC::CFGR::SW::Hsi::Set();
  // while (!RCC::CFGR::SWS::Hsi::IsSet()) { }

  RCC::APB2ENR::SYSCFGEN::Enable::Set();
  STK::CTRL::CLKSOURCE::CpuClock::Set();
  RCC::APB1ENR::TIM5EN::Enable::Set();

  NVIC::ISER1::Write(1 << 18U);

  const auto TimerDivider = SystemCoreClock / 1'000U;

  TIM5::PSC::Write(TimerDivider);
  TIM5::CR1::URS::Value1::Set();
  TIM5::ARR::Write(500U);
  TIM5::SR::UIF::Set(0);
  TIM5::CNT::Write(0);
  TIM5::DIER::UIE::Value1::Set();
  TIM5::CR1::CEN::Enable::Set();

  return 1;
}
}

bool isInterruptHappened = false;

int main()
{
  // Подаём тактирование на порт A
  RCC::AHB1ENR::GPIOAEN::Enable::Set();
  // Подаём тактирование на порт C
  RCC::AHB1ENR::GPIOCEN::Enable::Set();
  
  // Порт A.5 на вывод
  GPIOA::MODER::MODER5::Output::Set();
  // Порт C.5, C.8, C.9 на вывод
  GPIOC::MODER::MODER5::Output::Set();
  GPIOC::MODER::MODER8::Output::Set();
  GPIOC::MODER::MODER9::Output::Set();

  // Создаём объект кнопки, привязанной к выводу PC13 (EXTI)
  ButtonExti<GPIOC, 13> button;

  // Создаём объекты светодиодов
  Led<GPIOC, 5> led1;
  Led<GPIOC, 8> led2;
  Led<GPIOC, 9> led3;
  Led<GPIOA, 5> led4;

  // Собираем их в массив
  tLeds leds = { &led1, &led2, &led3, &led4 };

  // Создаём разные режимы (пример демонстрационной логики)
  AllMode allmode(leds);
  ChessMode chessmode(leds);
  TreeMode treemode(leds);

  // Список режимов для диспетчера
  tMode MODES = {
    &allmode,
    &chessmode,
    &treemode
  };

  // Создаём диспетчер режимов
  ModeManager modeManager(MODES);
  modeManager.InitModeManager();

  // Основной цикл
  for(;;)
  {
    if (isInterruptHappened)
    {
      // Обновление состояния режимов
      modeManager.UpdateModeManager();

      // Проверяем нажатие кнопки
      if(button.onClick())
      {
        // Переключаемся на следующий режим
        modeManager.SwitchModeManager();
      }
      isInterruptHappened = false;
    }
  }

  return 1;
}
----