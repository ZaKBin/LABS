= Лабораторная работа №3-4
Волбенко В.Д. <КЭ-413>
:description: Лабораторная работа №3-4
:toc:
:toc-title: Оглавление
:imagesdir: Pic
:figure-caption: Рисунок
:table-caption: Таблица

include::Titul.adoc[]

== Принцип single responsibility 

Принцип единственной ответственности (Single Responsibility Principle, SRP) — это один из ключевых принципов объектно-ориентированного программирования, входящий в состав концепции SOLID. Его основная идея заключается в том, что каждый класс, модуль или компонент системы должен иметь только одну причину для изменения. Другими словами, у него должна быть одна четко определенная зона ответственности.

Главное преимущество этого принципа состоит в упрощении поддержки и модификации кода. Если класс или модуль отвечает за выполнение одной задачи, изменения в этой задаче повлекут изменения только в этом конкретном компоненте, не затрагивая другие части системы. Это снижает вероятность возникновения ошибок и делает систему более устойчивой к изменениям.

Принцип SRP способствует более четкому разделению обязанностей между классами, что упрощает тестирование и повторное использование кода. Когда каждая часть системы занимается своей задачей, разработчику проще понять, как работает код, и быстрее находить решения для внесения улучшений.

Нарушение принципа часто приводит к созданию классов-монстров, которые содержат в себе слишком много логики и функционала. Такие классы сложны для тестирования, плохо поддаются расширению и делают систему уязвимой к багам. Поэтому важно проектировать код так, чтобы каждый компонент был сфокусирован на своей конкретной задаче.

== Open-Close принцип

Принцип открытости-закрытости (Open-Closed Principle, OCP) является вторым из принципов SOLID и гласит, что программные сущности (классы, модули, функции) должны быть открыты для расширения, но закрыты для изменения. Это значит, что поведение системы можно изменять или дополнять, не внося изменения в уже существующий код.

Основная идея принципа заключается в том, чтобы минимизировать влияние модификаций на стабильный, проверенный код. Вместо изменения существующего кода, разработчик добавляет новые модули или классы, которые реализуют нужное поведение. Такой подход помогает избежать ошибок, связанных с изменением уже работающих частей системы, и упрощает поддержку.

Реализация принципа обычно достигается за счет использования полиморфизма и абстракций. Например, вместо жесткой привязки к конкретным реализациям, системы проектируются через интерфейсы или абстрактные классы, которые могут быть реализованы или расширены новыми классами. Это позволяет добавлять новые функциональные возможности, просто создавая дополнительные реализации, без необходимости модификации базового кода.

Нарушение принципа приводит к тому, что изменения в одной части системы могут вызвать непредвиденные последствия в других ее частях. Это увеличивает риск багов и делает систему более сложной для сопровождения. Следование OCP помогает создавать гибкие и масштабируемые архитектуры, которые легче адаптировать к новым требованиям.

== Реализация кода для елочки,  с помощью указателей

Указатель — это переменная, которая хранит адрес другой переменной в памяти. В языке программирования C и C++ указатели широко используются для работы с памятью, так как они позволяют получать доступ к ячейкам памяти напрямую.

В этом коде реализован эффект "ёлочка": светодиоды по очереди зажигаются один за другим, создавая последовательный световой эффект, а затем также по очереди плавно гаснут.

Этот код включает и выключает светодиоды, подключённые к микроконтроллеру, поочерёдно, используя битовые маски для управления отдельными пинами GPIO. Вот как он работает:

* Битовые маски: Определены маски для пинов 5, 8, и 9, чтобы управлять состоянием отдельных светодиодов.
* Адреса портов: Указатели prtGpiocOdr и prtGpioaOdr указывают на регистры портов GPIOC и GPIOA для управления светодиодами.
* Бесконечный цикл: Включает и выключает светодиоды с задержкой, создавая эффект мигания.

Сначала каждый светодиод включается и задержка делает мигание видимым, затем они выключаются в той же последовательности:

[source, cpp]
----
// Битовые маски
const std::uint32_t maskBit5 = (1U << 5U);
const std::uint32_t maskBit8 = (1U << 8U);
const std::uint32_t maskBit9 = (1U << 9U);

// Указание адресов портов
std::uint32_t* const prtGpiocOdr = reinterpret_cast<uint32_t*>(0x40020814U); // Порт GPIOC
std::uint32_t* const prtGpioaOdr = reinterpret_cast<uint32_t*>(0x40020014U); // Порт GPIOA

for(;;)
{
    // Включение светодиодов
    *prtGpioaOdr |= maskBit5; // Светодиод LED1
    delay(1000000);

    *prtGpiocOdr |= maskBit9; // Светодиод LED2
    delay(1000000);

    *prtGpiocOdr |= maskBit8; // Светодиод LED3
    delay(1000000);

    *prtGpiocOdr |= maskBit5; // Светодиод LED4
    delay(1000000);

    // Выключение светодиодов
    *prtGpioaOdr &= ~maskBit5; // Светодиод LED1
    delay(1000000);

    *prtGpiocOdr &= ~maskBit9; // Светодиод LED2
    delay(1000000);

    *prtGpiocOdr &= ~maskBit8; // Светодиод LED3
    delay(1000000);

    *prtGpiocOdr &= ~maskBit5; // Светодиод LED4
    delay(1000000);

    return 1;
}
----

== Реализация кода с помощью класса

Ниже представлен код с использовать класс. 

Класс  — это шаблон для создания объектов, которые могут содержать данные и функции для работы с этими данными. Он объединяет данные (поля или атрибуты) и методы (функции), которые оперируют этими данными, в одной структуре.

Кратко что делается в этой программе:

* Интерфейс ILed — это виртуальный класс (интерфейс) с тремя чисто виртуальными методами (Light, Off, Toggle). Он определяет набор операций, которые конкретные классы (как Led) должны реализовать, но сам не содержит их реализации.
* Класс Led, наследующий ILed: Класс Led реализует интерфейс ILed и предоставляет конкретные реализации для управления светодиодом: 
. Light() — включает светодиод, устанавливая указанный бит в регистре порта.
. Off() — выключает светодиод, сбрасывая указанный бит.
. Toggle() — изменяет состояние светодиода на противоположное, используя операцию XOR.
* Поля класса Led:
. registerAddr — хранит адрес регистра GPIO.
. pinNum — хранит номер бита для управления конкретным светодиодом.

Таким образом, класс Led позволяет включать, выключать и переключать состояние светодиода по указанному адресу и пину, реализуя функции, заданные интерфейсом ILed.

[source, cpp]
----
// Создание виртуального класса
class ILed
{
    virtual void Light() = 0;
    virtual void Off() = 0;
    virtual void Toggle() = 0;
};

// Создание класса Led
class Led : public ILed
{
public:
    Led(std::uint32_t registerAddres, std::uint32_t pinNumber) : 
    registerAddr(registerAddres), pinNum(pinNumber) // Конструктор
    {
    }

    void Light() override // Функция включения светодиода
    {
        *reinterpret_cast<std::uint32_t*>(registerAddr) |= (1 << pinNum);
    }
    void Off() override // Функция выключения светодиода
    {
        *reinterpret_cast<std::uint32_t*>(registerAddr) &= ~(1 << pinNum);
    }
    void Toggle() override // Функция изменения состояния светодиода на противоположное
    {
        *reinterpret_cast<std::uint32_t*>(registerAddr) ^= (1 << pinNum);
    }
private:
    std::uint32_t registerAddr; // Адрес указываемого регистра (порта)
    std::uint32_t pinNum; // Номер указываемого номера бита
};
----

Далее используя класс напишим код для "елочки":

[source, cpp]
----
// Битовые маски
constexpr std::uint32_t maskBit5 = (1U << 5U);
constexpr std::uint32_t maskBit8 = (1U << 8U);
constexpr std::uint32_t maskBit9 = (1U << 9U);
// Указание портов
constexpr std::uint32_t gpiocOdrRegAddres = 0x40020814U;
constexpr std::uint32_t gpioaOdrRegAddres = 0x40020014U;
// Указатели
auto const gpioaOdrPtr = reinterpret_cast<std::uint32_t*>(gpioaOdrRegAddres);
auto const gpiocOdrPtr = reinterpret_cast<std::uint32_t*>(gpiocOdrRegAddres);

// Указание элементам массива (светодиодам) порта и бита
Led led1(gpioaOdrRegAddres, 5);
Led led2(gpiocOdrRegAddres, 9);
Led led3(gpiocOdrRegAddres, 8);
Led led4(gpiocOdrRegAddres, 5);

// Создание массива светодиодов
std::array<Led*, 4> leds = {
    &led1,
    &led2,
    &led3,
    &led4};

for(;;)
{
    for(auto it: leds)
    {
        it->Toggle(); // Включение/выключение светодиода
        delay(1000000);
    }
    
    return 1;
}
----

== Других режимов

В лабораторной работы были рассмотрены такие режимы как: елочка, все одновременно и шахматный порядк.*

Построим UML-диаграмму, показывающую обновленную структуру программы.

.UML-диаграмма
image::image1.png[]

На диаграмме показано, что функции включения/выключения светодиода (*Light, Off, Toggle*) реализованы с помощью отдельного класса (интерфейса). То есть, функции включения/выключения реализованы отдельно, что соответствует принципу *Single Responsibility*. В свою очередь, режимы работы светодиодов имеют два метода: обновление (*Update()*) и установление (*Init()*). Каждый из этих методов реализован отдельно в соответствующих классах режимов.

=== Режим шахматного порядка

в этом задании нужно реализовать, по очередное зажигание парных диодов, так называемый шахматный порядок.

[source, cpp]
----
class IMode
    {
      virtual void Update() = 0; // Обновление режима
      virtual void Init() = 0; // Установление режима
    };
----

Интерфейс (*IMode*) определяет два метода — Update() и Init(), — которые должны быть реализованы в каждом классе, создающем собственный режим. Это позволяет создавать несколько режимов для разных схем включения светодиодов, с возможностью переключаться между ними.

Класс (*ChessMode*) наследуется от (*IMode*) и реализует режим, при котором светодиоды включаются в шахматном порядке. .

[source, cpp]
----
using tLeds = std::array<ILed*, 4>; // Создание массива указателей на объекты виртуального класса

class ChessMode: public IMode
    {
    public:
      ChessMode(tLeds& ledsArr): leds(ledsArr)
      {
      }
      // Метод обновления режима
      void Update() override
      {
        for(auto it: leds)
        {
          it->Toggle();
        }
      }
      
      // Метод установления режима
      void Init() override
      {
        for(auto it: leds)
        {
          it->Light();
        }
        for(auto i=0; i< leds.size(); ++i)
        {
          if ((i%2)==0) // Условие четности
          {
            leds[i]->Toggle();
          }
        }
      }
    private:
      tLeds& leds;
    };
----

Метод (*Init()*) инициализирует шахматный порядок включения: сначала включает все светодиоды, а затем переключает состояние (включает или выключает) светодиоды с чётными индексами, чтобы создать шахматный узор.

Метод (*Update()*) обновляет состояние светодиодов, переключая каждый светодиод в противоположное состояние, сохраняя шахматный порядок.

=== Режим Одновременное включение 

Реализуем другой режим работы светодиодов, при котором все светодиоды зажигаются и гаснут одновременно.

[source, cpp]
----
class AllMode:public IMode
 {
 public:
    AllMode(tLeds& ledsArr): leds(ledsArr)
    {
        
    }
      void Update() override
      {
        for(auto it: leds)
        {
          it->Toggle();
        }
      }
      
      void Init() override
      {
        for(auto it: leds)
        {
          it->Light();
        }
        
      }
private:
 tLeds& leds;
 };
----

=== Режим елочка

[source, cpp]
----
class TreeMode:public IMode
 {
 public:
    TreeMode(tLeds& ledsArr): leds(ledsArr)
    {
        
    }
  void Update() override
  {  
    leds[currentLedIndex]->Switch();
    currentLedIndex++;
    if(currentLedIndex >= leds.size())
    {
      currentLedIndex=0;
    }
  }  
    
  void Init() override
  { 
    currentLedIndex=0;
    for(auto it: leds)
     {   
          it->Light();
     }   
 
   }   
    private:
      tLeds& leds;
      std::size_t currentLedIndex;
    };

      for(;;)
    
int main()
{  
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  GPIOA::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;

  
  Led<GPIOC, 5> led1;
  Led<GPIOC, 8> led2;
  Led<GPIOC, 9> led3;
  Led<GPIOA, 5> led4;

  
   tLeds leds = {
    &led1,
    &led2,
    &led3,
    &led4};

    TreeMode treemode(leds);
    treemode.Init();

  for(;;)
  {

   treemode.Update();
  
  }

}
----


== Вывод

В данной лабораторной работе были рассмотрены различные способы реализации программы с использованием классов. Можно сделать вывод, что использование классов делает код более структурированным, понятным и удобным для дальнейшего редактирования и расширения.