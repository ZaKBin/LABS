= Лабораторная работа №3-4
Волбенко В.Д. <КЭ-413>
:description: Лабораторная работа №3-4
:toc:
:toc-title: Оглавление
:imagesdir: Pic
:figure-caption: Рисунок
:table-caption: Таблица


== Реализация кода с помощью указателей

Указатель — это переменная, которая хранит адрес другой переменной в памяти. В языке программирования C и C++ указатели широко используются для работы с памятью, так как они позволяют получать доступ к ячейкам памяти напрямую.

Ниже представлен код. В этом коде реализуется зажигание диодов своим чередом и потом гасится диоды, так сказать "елочка".

Этот код включает и выключает светодиоды, подключённые к микроконтроллеру, поочерёдно, используя битовые маски для управления отдельными пинами GPIO. Вот как он работает:

* Битовые маски: Определены маски для пинов 5, 8, и 9, чтобы управлять состоянием отдельных светодиодов.
* Адреса портов: Указатели prtGpiocOdr и prtGpioaOdr указывают на регистры портов GPIOC и GPIOA для управления светодиодами.
* Бесконечный цикл: Включает и выключает светодиоды с задержкой, создавая эффект мигания.

Сначала каждый светодиод включается и задержка делает мигание видимым, затем они выключаются в той же последовательности:

[source, cpp]
----
// Битовые маски
const std::uint32_t maskBit5 = (1U << 5U);
const std::uint32_t maskBit8 = (1U << 8U);
const std::uint32_t maskBit9 = (1U << 9U);

// Указание адресов портов
std::uint32_t* const prtGpiocOdr = reinterpret_cast<uint32_t*>(0x40020814U); // Порт GPIOC
std::uint32_t* const prtGpioaOdr = reinterpret_cast<uint32_t*>(0x40020014U); // Порт GPIOA

for(;;)
{
    // Включение светодиодов
    *prtGpioaOdr |= maskBit5; // Светодиод LED1
    delay(1000000);

    *prtGpiocOdr |= maskBit9; // Светодиод LED2
    delay(1000000);

    *prtGpiocOdr |= maskBit8; // Светодиод LED3
    delay(1000000);

    *prtGpiocOdr |= maskBit5; // Светодиод LED4
    delay(1000000);

    // Выключение светодиодов
    *prtGpioaOdr &= ~maskBit5; // Светодиод LED1
    delay(1000000);

    *prtGpiocOdr &= ~maskBit9; // Светодиод LED2
    delay(1000000);

    *prtGpiocOdr &= ~maskBit8; // Светодиод LED3
    delay(1000000);

    *prtGpiocOdr &= ~maskBit5; // Светодиод LED4
    delay(1000000);

    return 1;
}
----

== Реализация кода с помощью класса

Ниже представлен код с использовать класс. 

Класс  — это шаблон для создания объектов, которые могут содержать данные и функции для работы с этими данными. Он объединяет данные (поля или атрибуты) и методы (функции), которые оперируют этими данными, в одной структуре.

Кратко что делается в этой программе:

* Интерфейс ILed — это виртуальный класс (интерфейс) с тремя чисто виртуальными методами (Light, Off, Toggle). Он определяет набор операций, которые конкретные классы (как Led) должны реализовать, но сам не содержит их реализации.
* Класс Led, наследующий ILed: Класс Led реализует интерфейс ILed и предоставляет конкретные реализации для управления светодиодом: 
. Light() — включает светодиод, устанавливая указанный бит в регистре порта.
. Off() — выключает светодиод, сбрасывая указанный бит.
. Toggle() — изменяет состояние светодиода на противоположное, используя операцию XOR.
* Поля класса Led:
. registerAddr — хранит адрес регистра GPIO.
. pinNum — хранит номер бита для управления конкретным светодиодом.

Таким образом, класс Led позволяет включать, выключать и переключать состояние светодиода по указанному адресу и пину, реализуя функции, заданные интерфейсом ILed.

[source, cpp]
----
// Создание виртуального класса
class ILed
{
    virtual void Light() = 0;
    virtual void Off() = 0;
    virtual void Toggle() = 0;
};

// Создание класса Led
class Led : public ILed
{
public:
    Led(std::uint32_t registerAddres, std::uint32_t pinNumber) : 
    registerAddr(registerAddres), pinNum(pinNumber) // Конструктор
    {
    }

    void Light() override // Функция включения светодиода
    {
        *reinterpret_cast<std::uint32_t*>(registerAddr) |= (1 << pinNum);
    }
    void Off() override // Функция выключения светодиода
    {
        *reinterpret_cast<std::uint32_t*>(registerAddr) &= ~(1 << pinNum);
    }
    void Toggle() override // Функция изменения состояния светодиода на противоположное
    {
        *reinterpret_cast<std::uint32_t*>(registerAddr) ^= (1 << pinNum);
    }
private:
    std::uint32_t registerAddr; // Адрес указываемого регистра (порта)
    std::uint32_t pinNum; // Номер указываемого номера бита
};
----

Далее используя класс напишим код для "елочки":

[source, cpp]
----
// Битовые маски
constexpr std::uint32_t maskBit5 = (1U << 5U);
constexpr std::uint32_t maskBit8 = (1U << 8U);
constexpr std::uint32_t maskBit9 = (1U << 9U);
// Указание портов
constexpr std::uint32_t gpiocOdrRegAddres = 0x40020814U;
constexpr std::uint32_t gpioaOdrRegAddres = 0x40020014U;
// Указатели
auto const gpioaOdrPtr = reinterpret_cast<std::uint32_t*>(gpioaOdrRegAddres);
auto const gpiocOdrPtr = reinterpret_cast<std::uint32_t*>(gpiocOdrRegAddres);

// Указание элементам массива (светодиодам) порта и бита
Led led1(gpioaOdrRegAddres, 5);
Led led2(gpiocOdrRegAddres, 9);
Led led3(gpiocOdrRegAddres, 8);
Led led4(gpiocOdrRegAddres, 5);

// Создание массива светодиодов
std::array<Led*, 4> leds = {
    &led1,
    &led2,
    &led3,
    &led4};

for(;;)
{
    for(auto it: leds)
    {
        it->Toggle(); // Включение/выключение светодиода
        delay(1000000);
    }
    
    return 1;
}
----

== Других режимов

В лабораторной работы были рассмотрены такие режимы как: елочка, все одновременно и шахматный порядк.*

Построим UML-диаграмму, показывающую обновленную структуру программы.

.UML-диаграмма
image::image1.png[]

На диаграмме показано, что функции включения/выключения светодиода (*Light, Off, Toggle*) реализованы с помощью отдельного класса (интерфейса). То есть, функции включения/выключения реализованы отдельно, что соответствует принципу *Single Responsibility*. В свою очередь, режимы работы светодиодов имеют два метода: обновление (*Update()*) и установление (*Init()*). Каждый из этих методов реализован отдельно в соответствующих классах режимов.

=== Режим шахматного порядка

в этом задании нужно реализовать, по очередное зажигание парных диодов, так называемый шахматный порядок.

[source, cpp]
----
class IMode
    {
      virtual void Update() = 0; // Обновление режима
      virtual void Init() = 0; // Установление режима
    };
----

Интерфейс (*IMode*) определяет два метода — Update() и Init(), — которые должны быть реализованы в каждом классе, создающем собственный режим. Это позволяет создавать несколько режимов для разных схем включения светодиодов, с возможностью переключаться между ними.

Класс (*ChessMode*) наследуется от (*IMode*) и реализует режим, при котором светодиоды включаются в шахматном порядке. .

[source, cpp]
----
using tLeds = std::array<ILed*, 4>; // Создание массива указателей на объекты виртуального класса

class ChessMode: public IMode
    {
    public:
      ChessMode(tLeds& ledsArr): leds(ledsArr)
      {
      }
      // Метод обновления режима
      void Update() override
      {
        for(auto it: leds)
        {
          it->Toggle();
        }
      }
      
      // Метод установления режима
      void Init() override
      {
        for(auto it: leds)
        {
          it->Light();
        }
        for(auto i=0; i< leds.size(); ++i)
        {
          if ((i%2)==0) // Условие четности
          {
            leds[i]->Toggle();
          }
        }
      }
    private:
      tLeds& leds;
    };
----

Метод (*Init()*) инициализирует шахматный порядок включения: сначала включает все светодиоды, а затем переключает состояние (включает или выключает) светодиоды с чётными индексами, чтобы создать шахматный узор.

Метод (*Update()*) обновляет состояние светодиодов, переключая каждый светодиод в противоположное состояние, сохраняя шахматный порядок.

=== Режим Одновременное включение 

Реализуем другой режим работы светодиодов, при котором все светодиоды зажигаются и гаснут одновременно.

[source, cpp]
----
class AllMode:public IMode
 {
 public:
    AllMode(tLeds& ledsArr): leds(ledsArr)
    {
        
    }
      void Update() override
      {
        for(auto it: leds)
        {
          it->Toggle();
        }
      }
      
      void Init() override
      {
        for(auto it: leds)
        {
          it->Light();
        }
        
      }
private:
 tLeds& leds;
 };
----

=== Режим елочка

[source, cpp]
----
class TreeMode:public IMode
 {
 public:
    TreeMode(tLeds& ledsArr): leds(ledsArr)
    {
        
    }
      void Update() override
      {
         for(auto it: leds)
        {
          it->Light();
        }
        for(auto i=0; i< leds.size(); ++i)
        {
            leds[i]->Toggle();
        }
      }
        void Init() override
      {
        for(auto it: leds)
        {
          it->Light();
        }
        for(auto i=0; i< leds.size(); ++i)
        {
            leds[i]->Toggle();
        }
      }
    private:
      tLeds& leds;
    };
----