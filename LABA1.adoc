= Отчет по лабораторной работе.
Автор
:imagesdir: pic
:toc:
:toc-title: Оглавление
:toclevels: 2
:figure-caption: Рисунок
:table-caption: Таблица

== Процесс разработки ПО

Процесс разработки программного обеспечения — процесс, посредством которого потребности пользователей преобразуются в программный продукт.

Процесс разработки ПО состоит из 7 этапов:

. Анализ требований: включает в себя сбор требований к ПО, состороны заказчика, Данный этап играет самую важную роль в разработки,так как маленькие уточнение в требовании, влияют на итоговый результат. 
. Проектирование программного обеспечения: Данный этап включает в себя такие виды деятельности, как выбор метода и стратегии решения,разработка основного алгоритма,тестирование и дт.
. Программирование: когда собрали требования(там же и установили на каком языке будет писаться ПО) и спроектировали, начинается процесс кодинга.
. Тестирование программного обеспечения: на данном этапе уже готовый код программы, начинается тестирование, и результаты тестирования должны удовлетворять требования ПО.
. Системная интеграция: В этапе проектирования, мы делили реализацию ПО на маленькие задачки, на этом этапе мы собираем в единую систему.
. Установка программного обеспечения: на данном этапе мы внедряем ПО в продукт для конечного использования. 
. Сопровождение программного обеспечения

== Компиляция кода, линковка и загрузка

Разберем каждый процесс по отдельности

=== Компиляция кода

Компиляция в программировании — это процесс преобразования исходного кода программы, написанного на языке программирования, в машинный код или другой язык, понятный компьютеру. Этот процесс выполняется с помощью программы, называемой компилятором.

Компилятор получает на вход файл с кодом на каком-то языке программирования. Он преобразовывает конструкции языка в формат, понятный компьютеру, и возвращает файл, который тот сможет выполнить.

Чтобы преобразовать исходный код, компилятор использует собственный словарь с определениями — например, оператор if меняет на двоичный код.

=== Линковка

После того, как компилятор создал один или несколько объектных файлов, включается другая программа — компоновщик или линкер. 

Работа компоновщика состоит из трех частей:

. Берет все объектные файлы, сгенерированные компилятором, и объединяет их в единую исполняемую программу;
. Помимо возможности связывать объектные файлы компоновщик также может связывать файлы библиотек. Файл библиотеки — это набор предварительно скомпилированного кода, который был упакован для повторного использования в других программах;
. Обеспечивает правильное разрешение всех межфайловых зависимостей. Если компоновщик не может связать ссылку с чем-то с ее определением, мы получим ошибку компоновщика, и процесс линковки прервется.

=== Загрузка

Последний этап, который предстоит пройти нашей программе — вызвать загрузчик для загрузки нашей программы в память. На данной стадии также возможна подгрузка динамических библиотек.

== Как происходит запуск кода на микроконтроллере

Программирование микроконтроллеров обозначает запись, необходимых для выполнения команд, в постоянную память микроконтроллера (ПЗУ). Этот процесс не может осуществляться без таких компонентов, как: программатор (используется для записи программы в микроконтроллер), язык программирования и сама программа (должны быть понятны для микроконтроллера) и знание структуры и параметров микроконтроллера для его рационального использования.

В первую очередь необходимо отметить, что одним из самых важных компонентов в программировании микроконтроллеров является программатор. Он осуществляет взаимосвязь между компьютером и микроконтроллером.

Выбор программатора влияет на получение наилучшего результата. Хороший программатор имеет возможность не только записывать ряд команд в контроллер, но и считывать информацию. При необходимости программатор может выполнять и другие функции, такие как стирание, защита от чтения, и т.д.

== Стек

Стек — полезная структура данных. Она похожа на стопку тарелок, сложенных друг на друга.

Размер стека играет важную роль в программе, тк может произойти переполнение, Ограничение на рекурсию, не хватит памяти для других целей и тд. 

.Визуализация стека.
image::Рисунок 2.png[]

Что можно сделать со стопкой тарелок?

. Положить сверху еще одну тарелку.
. Убрать верхнюю тарелку.

Если вы хотите взять нижнюю тарелку, то придется убрать все тарелки над ней. Этот принцип называется LIFO — Last In First Out («последним пришёл — первым ушёл»).

=== LIFO — принцип стека

Для стека доступны две операции — push и pop:

. push — помещение элемента в начало стека,
. pop — удаление.

.Принцип стека
image::Рисунок 3.png[]

Как видите, хоть элемент 3 и был добавлен последним, но удаляется он самым первым — так работает принцип LIFO.

=== Как работает стек

Стек работает следующим образом:

. Указатель TOP используется для отслеживания «верхнего» элемента стека.
. После инициализации стека его значение равно -1. Так можно легко проверить заполненность стека: если TOP == -1, стек пуст.
. Когда мы «проталкиваем» элемент, значение TOP увеличивается на единицу. Следующий элемент будет находиться на позиции TOP+1.
. Когда мы используем метод pop, мы удаляем элемент, на который указывает TOP. После этого его значение уменьшается на единицу.
. Перед добавлением нового элемента мы проверяем, не заполнен ли стек.
. Перед удалением мы проверяем, не пуст ли стек.

.Принцеп работы стека
image::Рисунок 4.png[]

=== Глобальный и локальные переменные

Глобальные переменные это те, которые существуют глобально, то есть доступны из любого места программы, и не исчезают до самого конца работы программы. Глобальной переменной становится любая переменная, которую мы объявили в главном теле программы (то есть не внутри функции)

В свою очередь, локальные переменные это те, которые объявляются внутри функции: они появляются тогда, когда функция начинает работать, видны только внутри этой функции, и исчезают после выхода из функции.

== Ответы на вопросы

1) Дайте определение понятию “Интегрированной среде разработки”::
Ответ:

Интегрированная среда разработки - программа, в которой разработчики пишут, проверяют, тестируют и запускают код, а также ведут большие проекты. Она включает в себя сразу несколько инструментов: редактор для написания кода, сервисы для его проверки и запуска, расширения для решения дополнительных задач разработки.

2) Что такое компилятор и чем он отличается от транслятора?::
Ответ:

Компилятор - транслятор, который осуществляет перевод исходной программы в эквивалентную ей объектную программу на языке машинных команд или языке ассемблера.

Транслятор - программа, которая переводит входную программу на исходном (входном) языке в эквивалентную ей выходную программу на результирующем (выходном) языке. 

Компилятор отличается от транслятора тем, что его результирующая программа всегда должна быть написана на языке машинных кодов или на языке ассемблера. Результирующая программа транслятора, в общем случае, может быть написана на любом языке. Соответственно, всякий компилятор является транслятором, но не наоборот.

3) Что такое компоновщик и какие функции он выполняет?::
Ответ: 

Компоновщик — инструментальная программа, которая производит компоновку («линковку»): принимает на вход один или несколько объектных модулей и собирает из них исполняемый или библиотечный файл-модуль.Для большинства компиляторов один объектный файл является результатом компиляции одного файла с исходным кодом. Если программа собирается из нескольких объектных файлов, компоновщик собирает эти файлы в единый исполняемый файл, вычисляя и подставляя адреса вместо символов, в течение времени компоновки (статическая компоновка) или во время исполнения (динамическая компоновка).

Компоновщик может извлекать объектные файлы из специальных коллекций, называемых библиотеками. Если не все символы, на которые ссылаются пользовательские объектные файлы, определены, то компоновщик ищет их определения в библиотеках, которые пользователь подал ему на вход. Обычно одна или несколько системных библиотек используются компоновщиком по умолчанию. Когда объектный файл, в котором содержится определение какого-либо искомого символа, найден, компоновщик может включить его (файл) в исполняемый файл (в случае статической компоновки) или отложить это до момента запуска программы (в случае динамической компоновки).

Работа компоновщика заключается в том, чтобы в каждом модуле определить и связать ссылки на неопределённые имена. Для каждого импортируемого имени находится его определение в других модулях, упоминание имени заменяется на его адрес.+ Компоновщик обычно не выполняет проверку типов и количества параметров процедур и функций. Если надо объединить объектные модули программ, написанные на языках со строгой типизацией, то необходимые проверки должны быть выполнены дополнительной утилитой перед запуском редактора связей.

4) Почему важен процесс проектирования ПО какие задачи входят в этот процесс?::
Ответ:

При разработке программного обеспечения начинать следует с проектирования — т.е. с полного планирования того, что непосредственно придётся разрабатывать, в какие сроки, с какими исходными данными и ожидаемым результатом.
Определив требования к программному обеспечению, разработчик получает согласованный четкий план действий, график оплат и сроков, сокращает время разработки и повышает её качество, а также позволяет предусмотреть любые другие нюансы разработки, например, юридические (в частности по передаче авторских прав на программное обеспечение).

Проектируя ПО заранее, разработчик получает возможность:

. оценить стоимость и время разработки программного продукта;
. исключить потери времени и денег на ненужные действия, вынужденные доработки, длительное согласование;
. избежать разногласий и неудовлетворённости клиента и исполнителя. При подготовке к проектированию решаются организационные вопросы;
. что клиент может предоставить (ТЗ, макеты, дизайн), насколько достаточны исходники и какие этапы закрывают — таким образом определяется состав работ;
. бюджет и сроки: на основе имеющихся материалов утверждается примерная стоимость, срок всего проекта, а также срок и точная стоимость ближайшего этапа.

5) Дорисуйте процесс разработки ПО, описанный на изображении <<IAR_Workbench>> с учетом итеративности связей в этом процессе::
Ответ: ---

6) Зачем нужная отладка и в каких случаях она применяется? Для чего применяются точки остановки?:: 
Ответ: 

Отладка – это процесс поиска и исправления ошибок или неполадок в исходном коде какого-либо программного обеспечения. Отладка необходимо для устранения неисправностей работы готовой программы.

Преднамеренное прерывание выполнения программы, при котором выполняется вызов отладчика. 

После перехода к отладчику программист может исследовать состояние программы (логи, состояние памяти, регистров процессора, стека и т. п.), с тем чтобы определить, правильно ли ведёт себя программа. В отличие от полной остановки, с помощью останова, после работы в отладчике программа может быть завершена либо продолжена с того же места, где произошёл останов.

7) Какие еще важные IAR workbench можно добавить в таблицу <<Характеристики IAR>>::
Ответ:

[#Характеристики IAR Embedded Workbench]
.Характеристики IAR Embedded Workbench
[options="header"]
|=====================
|Характеристика|IAR Embedded Workbench
|Языки               |С/C++
|Стандарты языка     |С++ 17 начиная с версии 8.40
|Оптимизация кода    |Да, кроме condition_variable, future, mutex, shared_mutex, thread, поддержка
atomic урезана и реализована только для типов для которых есть аппаратная поддержка atomic
специальными командами в микроконтроллерах
|Контроль размера стека  |Да
|Поддержка RTOS  |Да
|Статический анализатор кода с набором правил |Да - MISRAC++2008, SECURITY,CERT, STDCHECKS
|Динамический анализ кода  |C-RUN
|Сертификация и проверка соответствию стандартам безопасности  |Сертификация на безопасность по стандартам IEC 61508 и ISO 26262 экспертной организацией TUV SUD – SIL3 сертификат
|Поддержка микроконтроллера STM32F411 RE |Полная
|Обширные библиотеки |таких как IAR C/C++ Standard Library и тд.
|=====================

== Вывод
В данной работе изучил разработку ПО, понял как происходит компиляция кода, линковка и загрузка, расмотрел как происзодит запуск кода на микроконтроллере, основные характиристики стека и отвтеил на вопросы.