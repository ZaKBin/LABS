= Отчет по лабораторной работе.
Волбенко Валентин дмитриевич
:imagesdir: pic
:toc:
:toc-title: Оглавление
:toclevels: 2
:figure-caption: Рисунок
:table-caption: Таблица

== Процесс разработки ПО

Процесс разработки программного обеспечения — процесс, посредством которого потребности пользователей преобразуются в программный продукт.

Процесс разработки ПО состоит из 7 этапов:

. Анализ требований: включает в себя сбор требований к ПО, со стороны заказчика, данный этап играет самую важную роль в разработки, так как маленькие уточнения в требовании, влияют на итоговый результат. 
. Проектирование программного обеспечения: Данный этап включает в себя такие виды деятельности, как выбор метода и стратегии решения, разработка основного алгоритма, тестирование и т.д.
. Программирование: когда собрали требования (там же и установили на каком языке будет писаться ПО) и спроектировали, начинается процесс кодинга.
. Тестирование программного обеспечения: на данном этапе уже готовый код программы, начинается тестирование, и результаты тестирования должны удовлетворять требования ПО.
. Системная интеграция: В этапе проектирования, мы делили реализацию ПО на маленькие задачки, на этом этапе мы собираем в единую систему.
. Установка программного обеспечения: на данном этапе мы внедряем ПО в продукт для конечного использования. 
. Сопровождение программного обеспечения.

== Компиляция кода, линковка и загрузка

Разберем каждый процесс по отдельности

=== Компиляция

Компиляция - это процесс преобразования исходного кода программы, написанного на языке высокого уровня, в машинный код, с которым разбирается компьютер.

Суть компиляции заключается в том, что компилятор анализирует исходный код, проверяет его синтаксис, выявляет возможные ошибки и преобразует его в машинный код, понятный процессору. Это позволяет создавать сложные программы с помощью простого и понятного кода на языке высокого уровня, отделяя разработчика от низкоуровневых деталей.

Процесс компиляции состоит из следующих этапов:

. Лексический анализ. Последовательность символов исходного файла преобразуется в последовательность лексем.
Синтаксический анализ. Последовательность лексем преобразуется в дерево разбора.
. Семантический анализ. Дерево разбора обрабатывается с целью установления его семантики (смысла) — например, привязка идентификаторов к их декларациям, типам, проверка совместимости, определение типов выражений и т. д.
. Оптимизация. Выполняется удаление излишних конструкций и упрощение кода с сохранением его смысла.
. Генерация кода. Из промежуточного представления порождается объектный код.

Результатом компиляции является объектный код.

Объектный код — это программа на языке машинных кодов с частичным сохранением символьной информации, необходимой в процессе сборки.

Этапы компиляции представлены (рисунок <<pic1>>).

.Этапы компиляции
[#pic1]
image::Рисунок 1.jpg[]
 
=== Линковка

Линковка — это процесс, который объединяет разные части программы в единое целое.

Например, программа, написанная на языке вроде C или C++, и она состоит из нескольких модулей или файлов, где каждый файл содержит часть кода. После того как был написан весь код, необходимо его скомпилировать. Компилятор преобразует каждый файл в машинный код, но пока это отдельные части программы.

Когда компиляция завершена, нужно объединить эти части в один исполняемый файл — и это как раз то, что делает линковка.

=== Загрузка

Процесс загрузки программы на микроконтроллер включает несколько этапов. Это процесс, при котором скомпилированный машинный код переносится с компьютера на микроконтроллер, а затем начинается его выполнение. Рассмотрим процесс по этапно:

. Написание программы
. Компиляция программы: 
. Подключение микроконтроллера к компьютеру: 
. Использование загрузчика (bootloader): 
. Процесс записи в флэш-память: 
. Выполнение программы: После завершения загрузки программа начинается выполняться:
* После перезагрузки микроконтроллер начинает считывать инструкции из флэш-памяти с определённого адреса (обычно это начало программы, где располагается функция main).
* Программа выполняется последовательно, считывая инструкции из флэш-памяти и используя RAM для временных данных (например, для хранения переменных и стека).
. Обновление программы: Если необходимо обновить программу, весь процесс повторяется. Новая версия прошивки просто перезаписывает предыдущую программу во флэш-память. Обычно старые данные стираются перед записью новой программы.
. Завершение процесса: После загрузки и выполнения программы микроконтроллер продолжает свою работу, выполняя инструкции из флэш-памяти, пока не будет выключен или сброшен.

== Как происходит запуск кода на микроконтроллере

Запуск кода на микроконтроллере — это процесс, при котором микроконтроллер начинает выполнять программу, которую в него загрузили. Он состоит из нескольких этапов:

. Написание программы.
. Компиляция программы.
. Загрузка программы.
. Сброс микроконтроллера.
. Выполнение программы.
. Работа микроконтроллера в реальном времени.
. Бесконечный цикл.

Когда программа запускается на микроконтроллере, внутри него происходят несколько процессов, такие как:

. Подача питания и сброс (Reset).
. Начало работы загрузочного сектора (Bootloader).
. Инициализация железа.
. Загрузка программы в память.
. Запуск основной программы (main).
. Чтение и запись данных через порты ввода/вывода.
. Обработка прерываний (Interrupts).
. Бесконечный цикл (main loop).
. Работа с памятью.
. Энергосбережение.

== Стек

Стек — это структура данных, организованная по принципу LIFO (Last In, First Out), что означает, что последний добавленный элемент выходит первым. Это похоже на стопку тарелок: ты кладёшь новую тарелку сверху, и когда нужно взять одну, ты снимаешь сначала ту, что лежит наверху.

В контексте программ и микроконтроллеров стек используется для хранения временных данных, таких как:

* Локальные переменные.
* Адреса возврата.
* Параметры, переданные в функции.

Работа стека заключается в Добавление данных (Push) и Извлечение данных (Pop).

Для чего используется стек:

. Нехватка стека (переполнение): если стек слишком маленький, а программа вызывает много функций или использует много локальных переменных, это может привести к его переполнению. Когда стек переполняется, программа может начать перезаписывать важные данные в памяти, что может вызвать ошибки, неожиданное поведение или даже сбой программы.
. Излишне большой стек: если стек слишком большой, это может привести к неэффективному использованию памяти. Это особенно важно для микроконтроллеров с ограниченными ресурсами, поскольку выделение слишком много памяти под стек уменьшает доступное место для других данных и программ.
. Глубокая рекурсия: в рекурсивных функциях, когда функция вызывает саму себя, каждый новый вызов добавляет новую запись в стек. Если рекурсия слишком глубокая, программа может использовать всё доступное место в стеке, что приведёт к его переполнению (stack overflow).
. Производительность: хотя стек работает быстро, частое его использование, особенно с большими данными, может замедлить программу, так как приходится постоянно обращаться к памяти.

=== Глобальный и локальные переменные

Глобальные переменные это те, которые существуют глобально, то есть доступны из любого места программы, и не исчезают до самого конца работы программы. Глобальной переменной становится любая переменная, которую мы объявили в главном телепрограммы (то есть не внутри функции)

В свою очередь, локальные переменные это те, которые объявляются внутри функции: они появляются тогда, когда функция начинает работать, видны только внутри этой функции, и исчезают после выхода из функции.

== Ответы на вопросы

1) Дайте определение понятию “Интегрированной среде разработки”::
Ответ:

Интегрированная среда разработки - программа, в которой разработчики пишут, проверяют, тестируют и запускают код, а также ведут большие проекты. Она включает в себя сразу несколько инструментов: редактор для написания кода, сервисы для его проверки и запуска, расширения для решения дополнительных задач разработки.

2) Что такое компилятор и чем он отличается от транслятора?::
Ответ:

Компилятор - транслятор, который осуществляет перевод исходной программы в эквивалентную ей объектную программу на языке машинных команд или языке ассемблера.

Транслятор - программа, которая переводит входную программу на исходном (входном) языке в эквивалентную ей выходную программу на результирующем (выходном) языке. 

Компилятор отличается от транслятора тем, что его результирующая программа всегда должна быть написана на языке машинных кодов или на языке ассемблера. Результирующая программа транслятора, в общем случае, может быть написана на любом языке. Соответственно, всякий компилятор является транслятором, но не наоборот.

3) Что такое компоновщик и какие функции он выполняет?::
Ответ: 

Компоновщик — инструментальная программа, которая производит компоновку («линковку»): принимает на вход один или несколько объектных модулей и собирает из них исполняемый или библиотечный файл-модуль. Для большинства компиляторов один объектный файл является результатом компиляции одного файла с исходным кодом. Если программа собирается из нескольких объектных файлов, компоновщик собирает эти файлы в единый исполняемый файл, вычисляя и подставляя адреса вместо символов, в течение времени компоновки (статическая компоновка) или во время исполнения (динамическая компоновка).

Компоновщик может извлекать объектные файлы из специальных коллекций, называемых библиотеками. Если не все символы, на которые ссылаются пользовательские объектные файлы, определены, то компоновщик ищет их определения в библиотеках, которые пользователь подал ему на вход. Обычно одна или несколько системных библиотек используются компоновщиком по умолчанию. Когда объектный файл, в котором содержится определение какого-либо искомого символа, найден, компоновщик может включить его (файл) в исполняемый файл (в случае статической компоновки) или отложить это до момента запуска программы (в случае динамической компоновки).

Работа компоновщика заключается в том, чтобы в каждом модуле определить и связать ссылки на неопределённые имена. Для каждого импортируемого имени находится его определение в других модулях, упоминание имени заменяется на его адрес. + Компоновщик обычно не выполняет проверку типов и количества параметров процедур и функций. Если надо объединить объектные модули программ, написанные на языках со строгой типизацией, то необходимые проверки должны быть выполнены дополнительной утилитой перед запуском редактора связей.

4) Почему важен процесс проектирования ПО какие задачи входят в этот процесс?::
Ответ:

При разработке программного обеспечения начинать следует с проектирования — т.е. с полного планирования того, что непосредственно придётся разрабатывать, в какие сроки, с какими исходными данными и ожидаемым результатом.
Определив требования к программному обеспечению, разработчик получает согласованный четкий план действий, график оплат и сроков, сокращает время разработки и повышает её качество, а также позволяет предусмотреть любые другие нюансы разработки, например, юридические (в частности, по передаче авторских прав на программное обеспечение).

Проектируя ПО заранее, разработчик получает возможность:

. оценить стоимость и время разработки программного продукта;
. исключить потери времени и денег на ненужные действия, вынужденные доработки, длительное согласование;
. избежать разногласий и неудовлетворённости клиента и исполнителя. При подготовке к проектированию решаются организационные вопросы;
. что клиент может предоставить (ТЗ, макеты, дизайн), насколько достаточны исходники и какие этапы закрывают — таким образом определяется состав работ;
. бюджет и сроки: на основе имеющихся материалов утверждается примерная стоимость, срок всего проекта, а также срок и точная стоимость ближайшего этапа.

5) Дорисуйте процесс разработки ПО, описанный на изображении <<IAR_Workbench>> с учетом итеративности связей в этом процессе::
Ответ: ---

6) Зачем нужная отладка и в каких случаях она применяется? Для чего применяются точки остановки?:: 
Ответ: 

Отладка – это процесс поиска и исправления ошибок или неполадок в исходном коде какого-либо программного обеспечения. Отладка необходимо для устранения неисправностей работы готовой программы.

Преднамеренное прерывание выполнения программы, при котором выполняется вызов отладчика. 

После перехода к отладчику программист может исследовать состояние программы (логи, состояние памяти, регистров процессора, стека и т. п.), с тем чтобы определить, правильно ли ведёт себя программа. В отличие от полной остановки, с помощью останова, после работы в отладчике программа может быть завершена либо продолжена с того же места, где произошёл останов.

7) Какие еще важные IAR workbench можно добавить в таблицу <<Характеристики IAR>>::
Ответ:

[#Характеристики IAR Embedded Workbench]
.Характеристики IAR Embedded Workbench
[options="header"]
|=====================
|Характеристика|IAR Embedded Workbench
|Языки               |С/C++
|Стандарты языка     |С++ 17 начиная с версии 8.40
|Оптимизация кода    |Да, кроме condition_variable, future, mutex, shared_mutex, thread, поддержка
atomic урезана и реализована только для типов для которых есть аппаратная поддержка atomic
специальными командами в микроконтроллерах
|Контроль размера стека  |Да
|Поддержка RTOS  |Да
|Статический анализатор кода с набором правил |Да - MISRAC++2008, SECURITY,CERT, STDCHECKS
|Динамический анализ кода  |C-RUN
|Сертификация и проверка соответствию стандартам безопасности  |Сертификация на безопасность по стандартам IEC 61508 и ISO 26262 экспертной организацией TUV SUD – SIL3 сертификат
|Поддержка микроконтроллера STM32F411 RE |Полная
|Обширные библиотеки |таких как IAR C/C++ Standard Library и тд.
|=====================

== Вывод
В данной работе изучил разработку ПО, понял как происходит компиляция кода, линковка и загрузка, рассмотрел как происходит запуск кода на микроконтроллере, основные характеристики стека и ответил на вопросы.

